-- Generated by CSharp.lua Compiler
local System = System
local DelaunatorSharp = DelaunatorSharp
local KnapcodeFluteSharp = Knapcode.FluteSharp
local ListPoint = System.List(KnapcodeFluteSharp.Point)
local ArrayIPoint = System.Array(DelaunatorSharp.IPoint)
local ListBoolean = System.List(System.Boolean)
local KnapcodeFactorioTools
local KnapcodeOilField
local KnapcodeAddPipes
local ListGroup
local ListInt32
local ListTrunk
local ListTuple
local ListLocation
local ListPlanInfo
local ListSolution
local SpanLocation
local ArrayLocation
local NullableInt32
local QueueFlutePoint
local QueueValueTuple
local ListListLocation
local ListOilFieldPlan
local ListPathAndTurns
local ListTerminalPair
local ListPumpjackGroup
local ListTerminalLocation
local ListPumpjackConnection
local Comparer_1NullableInt32
local ILocationDictionary_1Int32
local KeyValuePairLocationILocationSet
local ILocationDictionary_1ILocationSet
local DictILocationSetSolutionsAndGroupNumber
local KeyValuePairLocationListTerminalLocation
local DictILocationDictionary_1ILocationSetListSolution
System.import(function (out)
  KnapcodeFactorioTools = Knapcode.FactorioTools
  KnapcodeOilField = Knapcode.FactorioTools.OilField
  KnapcodeAddPipes = Knapcode.FactorioTools.OilField.AddPipes
  ListGroup = System.List(KnapcodeAddPipes.Group)
  ListInt32 = System.List(System.Int32)
  ListTrunk = System.List(KnapcodeAddPipes.Trunk)
  ListTuple = System.List(System.Tuple)
  ListLocation = System.List(KnapcodeOilField.Location)
  ListPlanInfo = System.List(KnapcodeAddPipes.PlanInfo)
  ListSolution = System.List(KnapcodeAddPipes.Solution)
  SpanLocation = System.Span(KnapcodeOilField.Location)
  ArrayLocation = System.Array(KnapcodeOilField.Location)
  NullableInt32 = System.Nullable(System.Int32)
  QueueFlutePoint = System.Queue(KnapcodeAddPipes.FlutePoint)
  QueueValueTuple = System.Queue(System.ValueTuple)
  ListListLocation = System.List(ListLocation)
  ListOilFieldPlan = System.List(KnapcodeOilField.OilFieldPlan)
  ListPathAndTurns = System.List(KnapcodeAddPipes.PathAndTurns)
  ListTerminalPair = System.List(KnapcodeAddPipes.TerminalPair)
  ListPumpjackGroup = System.List(KnapcodeAddPipes.PumpjackGroup)
  ListTerminalLocation = System.List(KnapcodeOilField.TerminalLocation)
  ListPumpjackConnection = System.List(KnapcodeAddPipes.PumpjackConnection)
  Comparer_1NullableInt32 = System.Comparer_1(NullableInt32)
  ILocationDictionary_1Int32 = KnapcodeOilField.ILocationDictionary_1(System.Int32)
  KeyValuePairLocationILocationSet = System.KeyValuePair(KnapcodeOilField.Location, KnapcodeOilField.ILocationSet)
  ILocationDictionary_1ILocationSet = KnapcodeOilField.ILocationDictionary_1(KnapcodeOilField.ILocationSet)
  DictILocationSetSolutionsAndGroupNumber = System.Dictionary(KnapcodeOilField.ILocationSet, KnapcodeAddPipes.SolutionsAndGroupNumber)
  KeyValuePairLocationListTerminalLocation = System.KeyValuePair(KnapcodeOilField.Location, ListTerminalLocation)
  DictILocationDictionary_1ILocationSetListSolution = System.Dictionary(ILocationDictionary_1ILocationSet, ListSolution)
end)
System.namespace("Knapcode.FactorioTools.OilField", function (namespace)
  -- <summary>
  -- This "FBE" implementation is copied from Teoxoy's Factorio Blueprint Editor (FBE).
  -- Source:
  -- - https://github.com/teoxoy/factorio-blueprint-editor/blob/21ab873d8316a41b9a05c719697d461d3ede095d/packages/editor/src/core/generators/pipe.ts
  -- - https://github.com/teoxoy/factorio-blueprint-editor/blob/21ab873d8316a41b9a05c719697d461d3ede095d/packages/editor/src/core/generators/util.ts
  -- 
  -- Teoxoy came up with the idea to use Delaunay triangulation for this problem. Awesome!
  -- </summary>
  namespace.class("AddPipes", function (namespace)
    local Execute, GetBestSolution, GetAllPlans, GetSolutionGroups, OptimizeAndAddSolutions, GetSolution, EliminateStrandedTerminals, ExecuteWithFbe, 
    DelaunayTriangulation, GetNextLine, LineContainsAnAddedPumpjack, GetPathBetweenGroups, ConnectTwoGroups, Translations, GetConnectedPumpjacks, FindTrunksAndConnect, 
    GetShortestPathToGroup, GetCentroidDistanceSquared, FindTrunks, ConnectTwoClosestPumpjacks, GetChildCenters, GetTrunkCandidates, GetConnectedPumpjacksWithDelaunay, GetConnectedPumpjacksWithDelaunayMst, 
    GetDelauntator, GetConnectedPumpjacksWithFLUTE, GetLocationToFlutePoint, GetFluteTree, class, static
    namespace.class("SolutionsAndGroupNumber", function (namespace)
      local __members__, __ctor__
      __ctor__ = function (this, Solutions, GroupNumber)
        this.Solutions = Solutions
        this.GroupNumber = GroupNumber
      end
      __members__ = function ()
        return "SolutionsAndGroupNumber", "Solutions", "GroupNumber"
      end
      return {
        GroupNumber = 0,
        base = function (out)
          return {
            System.RecordType,
            System.IEquatable_1(out.Knapcode.FactorioTools.OilField.AddPipes.SolutionsAndGroupNumber)
          }
        end,
        __members__ = __members__,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("Solution", function (namespace)
      return {
        PipeCountWithoutUnderground = 0
      }
    end)
    namespace.class("LocationSetComparer", function (namespace)
      local Instance, EqualsOf, GetHashCodeOf, class, static
      static = function (this)
        Instance = class()
        this.Instance = Instance
      end
      EqualsOf = function (this, x, y)
        if x == nil and y == nil then
          return true
        end

        if x == nil then
          return false
        end

        if y == nil then
          return false
        end

        if x:getCount() ~= y:getCount() then
          return false
        end

        return x:SetEquals(y)
      end
      GetHashCodeOf = function (this, obj)
        local sumX = 0
        local minX = 2147483647 --[[Int32.MaxValue]]
        local maxX = -2147483648 --[[Int32.MinValue]]
        local sumY = 0
        local minY = 2147483647 --[[Int32.MaxValue]]
        local maxY = -2147483648 --[[Int32.MinValue]]

        for _, l in System.each(obj:EnumerateItems()) do
          sumX = sumX + l.X

          if l.X < minX then
            minX = l.X
          end

          if l.X > maxX then
            maxX = l.X
          end

          sumY = sumY + l.Y

          if l.Y < minY then
            minY = l.Y
          end

          if l.Y > maxY then
            maxY = l.Y
          end
        end

        local hash = 17
        hash = hash * 23 + obj:getCount()
        hash = hash * 23 + sumX
        hash = hash * 23 + minX
        hash = hash * 23 + maxX
        hash = hash * 23 + sumY
        hash = hash * 23 + minY
        hash = hash * 23 + maxY

        return hash
      end
      class = {
        base = function (out)
          return {
            System.IEqualityComparer_1(out.Knapcode.FactorioTools.OilField.ILocationSet)
          }
        end,
        EqualsOf = EqualsOf,
        GetHashCodeOf = GetHashCodeOf,
        static = static
      }
      return class
    end)
    namespace.class("ConnectedCentersComparer", function (namespace)
      local Instance, EqualsOf, GetHashCodeOf, class, static
      static = function (this)
        Instance = class()
        this.Instance = Instance
      end
      EqualsOf = function (this, x, y)
        if x == nil and y == nil then
          return true
        end

        if x == nil then
          return false
        end

        if y == nil then
          return false
        end

        if x:getCount() ~= y:getCount() then
          return false
        end

        for _, default in System.each(x:EnumeratePairs()) do
          local key, xValue = default:Deconstruct()
          local extern, yValue = y:TryGetValue(key)
          if not extern then
            return false
          end

          if not xValue:SetEquals(yValue) then
            return false
          end
        end

        return true
      end
      GetHashCodeOf = function (this, obj)
        local sumX = 0
        local minX = 2147483647 --[[Int32.MaxValue]]
        local maxX = -2147483648 --[[Int32.MinValue]]
        local sumY = 0
        local minY = 2147483647 --[[Int32.MaxValue]]
        local maxY = -2147483648 --[[Int32.MinValue]]
        local locationSum = 0

        for _, default in System.each(obj:EnumeratePairs()) do
          local l, s = default:Deconstruct()
          sumX = sumX + l.X

          if l.X < minX then
            minX = l.X
          end

          if l.X > maxX then
            maxX = l.X
          end

          sumY = sumY + l.Y

          if l.Y < minY then
            minY = l.Y
          end

          if l.Y > maxY then
            maxY = l.Y
          end

          locationSum = s:getCount()
        end

        local hash = 17
        hash = hash * 23 + obj:getCount()
        hash = hash * 23 + sumX
        hash = hash * 23 + minX
        hash = hash * 23 + maxX
        hash = hash * 23 + sumY
        hash = hash * 23 + minY
        hash = hash * 23 + maxY
        hash = hash * 23 + locationSum

        return hash
      end
      class = {
        base = function (out)
          return {
            System.IEqualityComparer_1(out.Knapcode.FactorioTools.OilField.ILocationDictionary_1(out.Knapcode.FactorioTools.OilField.ILocationSet))
          }
        end,
        EqualsOf = EqualsOf,
        GetHashCodeOf = GetHashCodeOf,
        static = static
      }
      return class
    end)
    namespace.class("PlanInfo", function (namespace)
      local __members__, __ctor__
      __ctor__ = function (this, GroupNumber, GroupSize, Plan, Pipes, Beacons)
        this.GroupNumber = GroupNumber
        this.GroupSize = GroupSize
        this.Plan = Plan
        this.Pipes = Pipes
        this.Beacons = Beacons
      end
      __members__ = function ()
        return "PlanInfo", "GroupNumber", "GroupSize", "Plan", "Pipes", "Beacons"
      end
      return {
        GroupNumber = 0,
        GroupSize = 0,
        base = function (out)
          return {
            System.RecordType,
            System.IEquatable_1(out.Knapcode.FactorioTools.OilField.AddPipes.PlanInfo)
          }
        end,
        __members__ = __members__,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("TwoConnectedGroups", function (namespace)
      local __ctor__
      __ctor__ = function (this, lines, minDistance, firstGroup)
        this.Lines = lines
        this.MinDistance = minDistance
        this.FirstGroup = firstGroup
      end
      return {
        MinDistance = 0,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("PathAndTurns", function (namespace)
      local __ctor__
      __ctor__ = function (this, endpoints, path, turns, originalIndex)
        this.Endpoints = endpoints
        this.Path = path
        this.Turns = turns
        this.OriginalIndex = originalIndex
      end
      return {
        Turns = 0,
        OriginalIndex = 0,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("Group", function (namespace)
      local getEntities, HasTerminal, Add, AddRange, UpdateLocation, internal, __ctor1__, __ctor2__, 
      __ctor3__
      internal = function (this)
        this.Location = KnapcodeOilField.Location.getInvalid()
      end
      __ctor1__ = function (this, context, terminal, paths)
        __ctor3__(this, context, paths)
        Add(this, terminal)
        UpdateLocation(this)
      end
      __ctor2__ = function (this, context, pair, paths)
        __ctor3__(this, context, paths)
        Add(this, pair.TerminalA)
        Add(this, pair.TerminalB)
        UpdateLocation(this)
      end
      __ctor3__ = function (this, context, paths)
        internal(this)
        this._terminals = context:GetLocationSet1()
        this._entities = ListTerminalLocation()
        this.Paths = paths
      end
      getEntities = function (this)
        return this._entities
      end
      HasTerminal = function (this, location)
        return this._terminals:Contains(location.Terminal)
      end
      Add = function (this, entity)
        this._entities:Add(entity)
        this._terminals:Add(entity.Terminal)
        this._sumX = this._sumX + entity.Center.X
        this._sumY = this._sumY + entity.Center.Y
        UpdateLocation(this)
      end
      AddRange = function (this, group)
        this._entities:AddRange(getEntities(group))
        this._terminals:UnionWith1(group._terminals)
        for i = 0, getEntities(group):getCount() - 1 do
          local entity = getEntities(group):get(i)
          this._sumX = this._sumX + entity.Center.X
          this._sumY = this._sumY + entity.Center.Y
        end
        UpdateLocation(this)
      end
      UpdateLocation = function (this)
        this.Location = KnapcodeOilField.Location(System.ToInt32(math.Round(this._sumX / #this._entities, 0)), System.ToInt32(math.Round(this._sumY / #this._entities, 0)))
      end
      return {
        _sumX = 0,
        _sumY = 0,
        getEntities = getEntities,
        HasTerminal = HasTerminal,
        Add = Add,
        AddRange = AddRange,
        __ctor__ = {
          __ctor1__,
          __ctor2__,
          __ctor3__
        }
      }
    end)
    namespace.class("PumpjackConnection", function (namespace)
      local GetAverageDistance, __ctor__
      __ctor__ = function (this, endpoints, connections, middle)
        this.Endpoints = endpoints
        this.Connections = connections
        this.EndpointDistance = endpoints.A:GetManhattanDistance(middle) + endpoints.B:GetManhattanDistance(middle)
      end
      GetAverageDistance = function (this)
        return (#this.Connections > 0) and KnapcodeFactorioTools.CollectionExtensions.Average(this.Connections, function (x)
          return #x.Line - 1
        end, KnapcodeAddPipes.TerminalPair) or 0
      end
      return {
        EndpointDistance = 0,
        GetAverageDistance = GetAverageDistance,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("TerminalPair", function (namespace)
      local ToString, __ctor__
      __ctor__ = function (this, terminalA, terminalB, line, middle)
        this.TerminalA = terminalA
        this.TerminalB = terminalB
        this.Line = line
        this.CenterDistance = terminalA.Terminal:GetManhattanDistance(middle)
      end
      ToString = function (this)
        return System.toString(this.TerminalA.Terminal) .. " -> " .. System.toString(this.TerminalB.Terminal) .. " (length " .. #this.Line .. ")"
      end
      return {
        CenterDistance = 0,
        ToString = ToString,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("GroupCandidate", function (namespace)
      local __members__, __ctor__
      __ctor__ = function (this, Group, Center, IncludedCenter, Terminal, Path)
        this.Group = Group
        this.Center = Center
        this.IncludedCenter = IncludedCenter
        this.Terminal = Terminal
        this.Path = Path
      end
      __members__ = function ()
        return "GroupCandidate", "Group", "Center", "IncludedCenter", "Terminal", "Path"
      end
      return {
        base = function (out)
          return {
            System.RecordType,
            System.IEquatable_1(out.Knapcode.FactorioTools.OilField.AddPipes.GroupCandidate)
          }
        end,
        __members__ = __members__,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("BestConnection", function (namespace)
      local __members__, __ctor__
      __ctor__ = function (this, Path, Terminal, BestTerminal)
        this.Path = Path
        this.Terminal = Terminal
        this.BestTerminal = BestTerminal
      end
      __members__ = function ()
        return "BestConnection", "Path", "Terminal", "BestTerminal"
      end
      return {
        base = function (out)
          return {
            System.RecordType,
            System.IEquatable_1(out.Knapcode.FactorioTools.OilField.AddPipes.BestConnection)
          }
        end,
        __members__ = __members__,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("Trunk", function (namespace)
      local getLength, getStart, getEnd, GetTrunkEndDistance, ToString, __ctor__
      __ctor__ = function (this, context, startingTerminal, center)
        this.Terminals = ListTerminalLocation(2)
        this._context = context
        this.TerminalLocations = context:GetLocationSet7(startingTerminal.Terminal, 2)
        this.Terminals:Add(startingTerminal)
        this.Centers = context:GetLocationSet8(center, 2, true)
      end
      getLength = function (this)
        return getStart(this):GetManhattanDistance(getEnd(this)) + 1
      end
      getStart = function (this)
        return this.Terminals:get(0).Terminal
      end
      getEnd = function (this)
        return this.Terminals:get(#this.Terminals - 1).Terminal
      end
      GetTrunkEndDistance = function (this, centerToConnectedCenters)
        if (this._trunkEndDistance ~= nil) then
          return System.Nullable.Value(this._trunkEndDistance)
        end

        local neighbors = this._context:GetLocationSet2(true)
        for _, center in System.each(this.Centers:EnumerateItems()) do
          for _, otherCenter in System.each(centerToConnectedCenters:get(center):EnumerateItems()) do
            neighbors:Add(otherCenter)
          end
        end

        neighbors:ExceptWith(this.Centers)

        if neighbors:getCount() == 0 then
          this._trunkEndDistance = 0
          return System.Nullable.Value(this._trunkEndDistance)
        end

        local centroidX = KnapcodeFactorioTools.CollectionExtensions.Average(neighbors:EnumerateItems(), function (l)
          return l.X
        end, KnapcodeOilField.Location)
        local centroidY = KnapcodeFactorioTools.CollectionExtensions.Average(neighbors:EnumerateItems(), function (l)
          return l.Y
        end, KnapcodeOilField.Location)
        this._trunkEndDistance = getStart(this):GetEuclideanDistance1(centroidX, centroidY) + getEnd(this):GetEuclideanDistance1(centroidX, centroidY)
        return System.Nullable.Value(this._trunkEndDistance)
      end
      ToString = function (this)
        return System.toString(getStart(this)) .. " -> " .. System.toString(getEnd(this))
      end
      return {
        OriginalIndex = 0,
        getLength = getLength,
        getStart = getStart,
        getEnd = getEnd,
        GetTrunkEndDistance = GetTrunkEndDistance,
        ToString = ToString,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("PumpjackGroup", function (namespace)
      local GetChildCentroidDistanceSquared, ConnectPumpjack, MergeGroup, UpdateFrontierCenters, UpdateIncludedCenterToChildCenters, __ctor1__, __ctor2__
      __ctor1__ = function (this, context, centerToConnectedCenters, allIncludedCenters, trunk)
        __ctor2__(this, context, centerToConnectedCenters, allIncludedCenters, trunk.Centers:EnumerateItems(), KnapcodeOilField.Helpers.MakeStraightLine(trunk:getStart(), trunk:getEnd()))
      end
      __ctor2__ = function (this, context, centerToConnectedCenters, allIncludedCenters, includedCenters, pipes)
        this._context = context
        this._centerToConnectedCenters = centerToConnectedCenters
        this._allIncludedCenters = allIncludedCenters

        this.IncludedCenters = KnapcodeFactorioTools.SetHandling.ToReadOnlySet1(includedCenters, context, true)

        this.FrontierCenters = context:GetLocationSet2(true)
        this.IncludedCenterToChildCenters = context:GetLocationDictionary(KnapcodeOilField.ILocationSet)

        this.Pipes = KnapcodeFactorioTools.SetHandling.ToSet(pipes, context, true)

        UpdateFrontierCenters(this)
        UpdateIncludedCenterToChildCenters(this)
      end
      GetChildCentroidDistanceSquared = function (this, includedCenter, terminalCandidate)
        local sumX = 0
        local sumY = 0
        local count = 0
        for _, center in System.each(this.IncludedCenterToChildCenters:get(includedCenter):EnumerateItems()) do
          sumX = sumX + center.X
          sumY = sumY + center.Y
          count = count + 1
        end

        local centroidX = sumX / count
        local centroidY = sumY / count

        return terminalCandidate:GetEuclideanDistanceSquared2(centroidX, centroidY)
      end
      ConnectPumpjack = function (this, center, path)
        this._allIncludedCenters:Add(center)
        this.IncludedCenters:Add(center)
        this.Pipes:UnionWith(path)
        UpdateFrontierCenters(this)
        UpdateIncludedCenterToChildCenters(this)
      end
      MergeGroup = function (this, other, path)
        this.IncludedCenters:UnionWith1(other.IncludedCenters)
        this.Pipes:UnionWith(path)
        this.Pipes:UnionWith1(other.Pipes)
        UpdateFrontierCenters(this)
        UpdateIncludedCenterToChildCenters(this)
      end
      UpdateFrontierCenters = function (this)
        this.FrontierCenters:Clear()

        for _, center in System.each(this.IncludedCenters:EnumerateItems()) do
          this.FrontierCenters:UnionWith1(this._centerToConnectedCenters:get(center))
        end

        this.FrontierCenters:ExceptWith(this.IncludedCenters)
      end
      UpdateIncludedCenterToChildCenters = function (this)
        this.IncludedCenterToChildCenters:Clear()

        for _, center in System.each(this.IncludedCenters:EnumerateItems()) do
          local visited = GetChildCenters(this._context, this._centerToConnectedCenters, this.IncludedCenters, this._allIncludedCenters, center)

          this.IncludedCenterToChildCenters:Add(center, visited)
        end
      end
      return {
        GetChildCentroidDistanceSquared = GetChildCentroidDistanceSquared,
        ConnectPumpjack = ConnectPumpjack,
        MergeGroup = MergeGroup,
        __ctor__ = {
          __ctor1__,
          __ctor2__
        }
      }
    end)
    namespace.class("FlutePoint", function (namespace)
      local getIsSteinerPoint, ToString, __ctor__
      __ctor__ = function (this, context, location)
        this.Terminals = ListTerminalLocation()
        this.Location = location
        this.Centers = context:GetLocationSet2(true)
        this.Neighbors = context:GetLocationSet2(true)
      end
      getIsSteinerPoint = function (this)
        return this.Centers:getCount() == 0
      end
      ToString = function (this)
        return this.Location:ToString()
      end
      return {
        IsEliminated = false,
        getIsSteinerPoint = getIsSteinerPoint,
        ToString = ToString,
        __ctor__ = __ctor__
      }
    end)
    static = function (this)
      Translations = ArrayLocation(2, {
        KnapcodeOilField.Location(1, 0),
        KnapcodeOilField.Location(0, 1)
      })
    end
    Execute = function (context, eliminateStrandedTerminals)
      if eliminateStrandedTerminals then
        EliminateStrandedTerminals(context)
      end

      local selectedPlans
      local alternatePlans
      local unusedPlans
      local bestSolution
      local bestBeacons

      System.try(function ()
        selectedPlans, alternatePlans, unusedPlans, bestSolution, bestBeacons = GetBestSolution(context):Deconstruct()
      end, function (default)
        if System.when(function ()
          return not eliminateStrandedTerminals
        end) and System.is(default, KnapcodeFactorioTools.NoPathBetweenTerminalsException) then
          EliminateStrandedTerminals(context)
          selectedPlans, alternatePlans, unusedPlans, bestSolution, bestBeacons = GetBestSolution(context):Deconstruct()
        else
          return 1, default
        end
      end)

      context.CenterToTerminals = bestSolution.CenterToTerminals
      context.LocationToTerminals = bestSolution.LocationToTerminals

      KnapcodeOilField.AddPipeEntities.Execute(context, bestSolution.Pipes, bestSolution.UndergroundPipes)

      if bestBeacons ~= nil then
        -- Visualizer.Show(context.Grid, bestSolution.Beacons.Select(c => (DelaunatorSharp.IPoint)new DelaunatorSharp.Point(c.X, c.Y)), Array.Empty<DelaunatorSharp.IEdge>());
        KnapcodeOilField.Helpers.AddBeaconsToGrid(context.Grid, context.Options, bestBeacons.Beacons)
      end

      return System.ValueTuple(selectedPlans, alternatePlans, unusedPlans)
    end
    GetBestSolution = function (context)
      local sortedPlans = GetAllPlans(context)
      sortedPlans:Sort(function (a, b)
        -- more effects = better
        local c = System.Int32.CompareTo(b.Plan.BeaconEffectCount, a.Plan.BeaconEffectCount)
        if c ~= 0 then
          return c
        end

        -- fewer beacons = better (less power)
        c = System.Int32.CompareTo(a.Plan.BeaconCount, b.Plan.BeaconCount)
        if c ~= 0 then
          return c
        end

        -- fewer pipes = better
        c = System.Int32.CompareTo(a.Plan.PipeCount, b.Plan.PipeCount)
        if c ~= 0 then
          return c
        end

        -- prefer solutions that more algorithms find
        c = System.Int32.CompareTo(b.GroupSize, a.GroupSize)
        if c ~= 0 then
          return c
        end

        -- the rest of the sorting is for arbitrary tie breaking
        c = System.Enum.CompareToObj(a.Plan.PipeStrategy, b.Plan.PipeStrategy)
        if c ~= 0 then
          return c
        end

        c = System.Boolean.CompareTo(a.Plan.OptimizePipes, b.Plan.OptimizePipes)
        if c ~= 0 then
          return c
        end

        c = Comparer_1NullableInt32.getDefault():Compare(a.Plan.BeaconStrategy, b.Plan.BeaconStrategy)
        if c ~= 0 then
          return c
        end

        return System.Int32.CompareTo(a.GroupNumber, b.GroupNumber)
      end)

      local bestPlanInfo = nil
      local noMoreAlternates = false
      local selectedPlans = ListOilFieldPlan()
      local alternatePlans = ListOilFieldPlan()
      local unusedPlans = ListOilFieldPlan()

      for _, planInfo in System.each(sortedPlans) do
        local continue
        repeat
          if noMoreAlternates then
            unusedPlans:Add(planInfo.Plan)
            continue = true
            break
          elseif bestPlanInfo == nil then
            bestPlanInfo = planInfo
            selectedPlans:Add(planInfo.Plan)
            continue = true
            break
          end

          local bestGroupNumber, _, bestPlan, _, _ = bestPlanInfo:Deconstruct()
          if planInfo.Plan:IsEquivalent(bestPlan) then
            if planInfo.GroupNumber == bestGroupNumber then
              selectedPlans:Add(planInfo.Plan)
            else
              alternatePlans:Add(planInfo.Plan)
            end
          else
            noMoreAlternates = true
            unusedPlans:Add(planInfo.Plan)
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      if bestPlanInfo == nil then
        System.throw(KnapcodeFactorioTools.FactorioToolsException("At least one pipe strategy must be used."))
      end

      return System.ValueTuple(selectedPlans, alternatePlans, unusedPlans, bestPlanInfo.Pipes, bestPlanInfo.Beacons)
    end
    GetAllPlans = function (context)
      local solutionGroups = GetSolutionGroups(context)
      local plans = ListPlanInfo()
      for _, default in System.each(solutionGroups) do
        local solutionGroup, groupNumber = default:Deconstruct()
        for _, solution in System.each(solutionGroup) do
          if solution.BeaconSolutions == nil then
            for _, strategy in System.each(solution.Strategies) do
              for _, optimized in System.each(solution.Optimized) do
                local plan = KnapcodeOilField.OilFieldPlan(strategy, optimized, nil, 0, 0, solution.Pipes:getCount(), solution.PipeCountWithoutUnderground)

                plans:Add(class.PlanInfo(groupNumber, #solutionGroup, plan, solution))
              end
            end
          else
            for _, beacons in System.each(solution.BeaconSolutions) do
              for _, strategy in System.each(solution.Strategies) do
                for _, optimized in System.each(solution.Optimized) do
                  local plan = KnapcodeOilField.OilFieldPlan(strategy, optimized, beacons.Strategy, beacons.Effects, #beacons.Beacons, solution.Pipes:getCount(), solution.PipeCountWithoutUnderground)

                  plans:Add(class.PlanInfo(groupNumber, #solutionGroup, plan, solution, beacons))
                end
              end
            end
          end
        end
      end

      return plans
    end
    GetSolutionGroups = function (context)
      local originalCenterToTerminals = context.CenterToTerminals
      local originalLocationToTerminals = context.LocationToTerminals

      local pipesToSolutions = DictILocationSetSolutionsAndGroupNumber(class.LocationSetComparer.Instance)
      local connectedCentersToSolutions = DictILocationDictionary_1ILocationSetListSolution(class.ConnectedCentersComparer.Instance)

      if context.CenterToTerminals:getCount() == 1 then
        local terminal = KnapcodeFactorioTools.CollectionExtensions.Single(context.CenterToTerminals:EnumeratePairs(), KeyValuePairLocationListTerminalLocation)[2]:get(0)
        KnapcodeOilField.Helpers.EliminateOtherTerminals(context, terminal)
        local pipes = context:GetSingleLocationSet(terminal.Terminal)
        local solutions = OptimizeAndAddSolutions(context, pipesToSolutions, 0, pipes)
        local solution = KnapcodeFactorioTools.CollectionExtensions.Single(solutions, class.Solution)
        solution.Strategies:Clear()
        solution.Strategies:AddRange(context.Options.PipeStrategies)
      else
        local completedStrategies = System.new(KnapcodeOilField.CustomCountedBitArray, 2, 5 --[[(int)PipeStrategy.ConnectedCentersFlute + 1]])
        -- max value
        for _, strategy in System.each(context.Options.PipeStrategies) do
          local continue
          repeat
            if completedStrategies:get(strategy) then
              continue = true
              break
            end

            context.CenterToTerminals = KnapcodeFactorioTools.SetHandling.ToDictionary(originalCenterToTerminals:EnumeratePairs(), context, function (x)
              return x[1]
            end, function (x)
              return KnapcodeFactorioTools.CollectionExtensions.ToList(x[2], KnapcodeOilField.TerminalLocation)
            end, KeyValuePairLocationListTerminalLocation, ListTerminalLocation)
            context.LocationToTerminals = KnapcodeFactorioTools.SetHandling.ToDictionary(originalLocationToTerminals:EnumeratePairs(), context, function (x)
              return x[1]
            end, function (x)
              return KnapcodeFactorioTools.CollectionExtensions.ToList(x[2], KnapcodeOilField.TerminalLocation)
            end, KeyValuePairLocationListTerminalLocation, ListTerminalLocation)

            repeat
              if strategy == 0 --[[PipeStrategy.FbeOriginal]] or strategy == 1 --[[PipeStrategy.Fbe]] then
                do
                  local pipes, finalStrategy = ExecuteWithFbe(context, strategy):Deconstruct()
                  completedStrategies:set(finalStrategy, true)

                  OptimizeAndAddSolutions(context, pipesToSolutions, finalStrategy, pipes)
                end
                break
              elseif strategy == 2 --[[PipeStrategy.ConnectedCentersDelaunay]] or strategy == 3 --[[PipeStrategy.ConnectedCentersDelaunayMst]] or strategy == 4 --[[PipeStrategy.ConnectedCentersFlute]] then
                do
                  local centerToConnectedCenters = GetConnectedPumpjacks(context, strategy)
                  completedStrategies:set(strategy, true)

                  local default, solutions = connectedCentersToSolutions:TryGetValue(centerToConnectedCenters, nil)
                  if default then
                    for _, solution in System.each(solutions) do
                      solution.Strategies:Add(strategy)
                    end
                    continue = true
                    break
                  end

                  local pipes = FindTrunksAndConnect(context, centerToConnectedCenters)
                  solutions = OptimizeAndAddSolutions(context, pipesToSolutions, strategy, pipes, centerToConnectedCenters)
                  connectedCentersToSolutions:AddKeyValue(centerToConnectedCenters, solutions)
                end
                break
              else
                System.throw(System.NotImplementedException())
              end
            until 1
            continue = true
          until 1
          if not continue then
            break
          end
        end
      end

      return pipesToSolutions:getValues()
    end
    OptimizeAndAddSolutions = function (context, pipesToSolutions, strategy, pipes, centerToConnectedCenters)
      local solutionsAndIndex
      local default
      default, solutionsAndIndex = pipesToSolutions:TryGetValue(pipes, nil)
      if default then
        for _, solution in System.each(solutionsAndIndex.Solutions) do
          solution.Strategies:Add(strategy)
        end

        return solutionsAndIndex.Solutions
      end

      -- Visualizer.Show(context.Grid, pipes.Select(p => (IPoint)new Point(p.X, p.Y)), Array.Empty<IEdge>());

      local originalCenterToTerminals = context.CenterToTerminals
      local originalLocationToTerminals = context.LocationToTerminals

      local optimizedPipes = pipes
      if context.Options.OptimizePipes then
        context.CenterToTerminals = KnapcodeFactorioTools.SetHandling.ToDictionary(originalCenterToTerminals:EnumeratePairs(), context, function (x)
          return x[1]
        end, function (x)
          return KnapcodeFactorioTools.CollectionExtensions.ToList(x[2], KnapcodeOilField.TerminalLocation)
        end, KeyValuePairLocationListTerminalLocation, ListTerminalLocation)
        context.LocationToTerminals = KnapcodeFactorioTools.SetHandling.ToDictionary(originalLocationToTerminals:EnumeratePairs(), context, function (x)
          return x[1]
        end, function (x)
          return KnapcodeFactorioTools.CollectionExtensions.ToList(x[2], KnapcodeOilField.TerminalLocation)
        end, KeyValuePairLocationListTerminalLocation, ListTerminalLocation)
        optimizedPipes = context:GetLocationSet(pipes)
        KnapcodeOilField.RotateOptimize.Execute(context, optimizedPipes)

        -- Visualizer.Show(context.Grid, optimizedPipes.Select(p => (IPoint)new Point(p.X, p.Y)), Array.Empty<IEdge>());
      end

      local solutions
      if pipes:SetEquals(optimizedPipes) then
        local extern
        if context.Options.UseUndergroundPipes then
          extern = context:GetLocationSet(pipes)
        else
          extern = pipes
        end
        optimizedPipes = extern
        local ref = ListSolution()
        ref:Add(GetSolution(context, strategy, false, centerToConnectedCenters, optimizedPipes))
        solutions = ref

        if context.Options.OptimizePipes then
          solutions:get(0).Optimized:Add(true)
        end
      else
        local solutionA = GetSolution(context, strategy, true, centerToConnectedCenters, optimizedPipes)

        context.CenterToTerminals = KnapcodeFactorioTools.SetHandling.ToDictionary(originalCenterToTerminals:EnumeratePairs(), context, function (x)
          return x[1]
        end, function (x)
          return KnapcodeFactorioTools.CollectionExtensions.ToList(x[2], KnapcodeOilField.TerminalLocation)
        end, KeyValuePairLocationListTerminalLocation, ListTerminalLocation)
        context.LocationToTerminals = KnapcodeFactorioTools.SetHandling.ToDictionary(originalLocationToTerminals:EnumeratePairs(), context, function (x)
          return x[1]
        end, function (x)
          return KnapcodeFactorioTools.CollectionExtensions.ToList(x[2], KnapcodeOilField.TerminalLocation)
        end, KeyValuePairLocationListTerminalLocation, ListTerminalLocation)
        local extern
        if context.Options.UseUndergroundPipes then
          extern = context:GetLocationSet(pipes)
        else
          extern = pipes
        end
        local pipesB = extern
        local solutionB = GetSolution(context, strategy, false, centerToConnectedCenters, pipesB)

        KnapcodeOilField.Validate.PipesDoNotMatch(context, solutionA.Pipes, solutionA.UndergroundPipes, solutionB.Pipes, solutionB.UndergroundPipes)

        local ref = ListSolution()
        ref:Add(solutionA)
        ref:Add(solutionB)
        solutions = ref
      end

      pipesToSolutions:AddKeyValue(pipes, class.SolutionsAndGroupNumber(solutions, pipesToSolutions:getCount() + 1))

      return solutions
    end
    GetSolution = function (context, strategy, optimized, centerToConnectedCenters, optimizedPipes)
      KnapcodeOilField.Validate.PipesAreConnected(context, optimizedPipes)

      local pipeCountBeforeUnderground = optimizedPipes:getCount()

      local undergroundPipes = nil
      if context.Options.UseUndergroundPipes then
        undergroundPipes = KnapcodeOilField.PlanUndergroundPipes.Execute(context, optimizedPipes)
      end

      local beaconSolutions = nil
      if context.Options.AddBeacons then
        beaconSolutions = KnapcodeOilField.PlanBeacons.Execute(context, optimizedPipes)
      end

      KnapcodeOilField.Validate.NoOverlappingEntities(context, optimizedPipes, undergroundPipes, beaconSolutions)

      -- Visualizer.Show(context.Grid, optimizedPipes.Select(p => (DelaunatorSharp.IPoint)new DelaunatorSharp.Point(p.X, p.Y)), Array.Empty<DelaunatorSharp.IEdge>());

      local default = class.Solution()
      local extern = ListInt32()
      extern:Add(strategy)
      default.Strategies = extern
      local extern = ListBoolean()
      extern:Add(optimized)
      default.Optimized = extern
      default.CenterToConnectedCenters = centerToConnectedCenters
      default.CenterToTerminals = context.CenterToTerminals
      default.LocationToTerminals = context.LocationToTerminals
      default.PipeCountWithoutUnderground = pipeCountBeforeUnderground
      default.Pipes = optimizedPipes
      default.UndergroundPipes = undergroundPipes
      default.BeaconSolutions = beaconSolutions
      return default
    end
    EliminateStrandedTerminals = function (context)
      local locationsToExplore = KnapcodeFactorioTools.SetHandling.ToReadOnlySet1(context.LocationToTerminals:getKeys(), context, true)

      while locationsToExplore:getCount() > 0 do
        local goals = context:GetLocationSet(locationsToExplore)
        local start = KnapcodeFactorioTools.CollectionExtensions.First(goals:EnumerateItems(), KnapcodeOilField.Location)
        goals:Remove(start)

        local result = KnapcodeOilField.Dijkstras.GetShortestPaths(context, context.Grid, start, goals, false, true)

        local reachedTerminals = result.ReachedGoals
        reachedTerminals:Add(start)

        local unreachedTerminals = context:GetLocationSet(goals)
        unreachedTerminals:ExceptWith(result.ReachedGoals)

        local reachedPumpjacks = context:GetLocationSet1()
        for _, location in System.each(result.ReachedGoals:EnumerateItems()) do
          local terminals = context.LocationToTerminals:get(location)
          for i = 0, #terminals - 1 do
            reachedPumpjacks:Add(terminals:get(i).Center)
          end
        end

        local terminalsToEliminate
        if reachedPumpjacks:getCount() == context.CenterToTerminals:getCount() then
          terminalsToEliminate = unreachedTerminals
          locationsToExplore:Clear()
        else
          terminalsToEliminate = reachedTerminals
          locationsToExplore = unreachedTerminals
        end

        local strandedTerminal = KnapcodeOilField.Location.getInvalid()
        local foundStranded = false
        for _, location in System.each(terminalsToEliminate:EnumerateItems()) do
          for _, terminal in System.each(context.LocationToTerminals:get(location)) do
            local terminals = context.CenterToTerminals:get(terminal.Center)
            terminals:Remove(terminal)

            if #terminals == 0 then
              strandedTerminal = terminal.Terminal
              foundStranded = true
            end
          end

          context.LocationToTerminals:Remove(location)
        end

        if foundStranded then
          --[[
                var clone = new PipeGrid(context.Grid);
                AddPipeEntities.Execute(clone, new(), context.CenterToTerminals, new ILocationSet(), undergroundPipes: null, allowMultipleTerminals: true);
                Visualizer.Show(clone, new[] { strandedTerminal.Value, locationsToExplore.First() }.Select(x => (IPoint)new Point(x.X, x.Y)), Array.Empty<IEdge>());
                ]]

          System.throw(KnapcodeFactorioTools.NoPathBetweenTerminalsException(strandedTerminal, KnapcodeFactorioTools.CollectionExtensions.First(locationsToExplore:EnumerateItems(), KnapcodeOilField.Location)))
        end
      end
    end
    ExecuteWithFbe = function (context, strategy)
      -- HACK: it appears FBE does not adjust the grid middle by the 2 cell buffer added to the side of the grid.
      -- We'll apply this hack for now to reproduce FBE results.
      local middle = context.Grid.Middle:Translate(- 2, - 2)

      local terminals, pipes, finalStrategy = DelaunayTriangulation(context, middle, strategy):Deconstruct()

      for _, terminal in System.each(terminals) do
        KnapcodeOilField.Helpers.EliminateOtherTerminals(context, terminal)
      end

      return System.ValueTuple(pipes, finalStrategy)
    end
    DelaunayTriangulation = function (context, middle, strategy)
      -- GENERATE LINES
      local lines = ListPumpjackConnection()
      local allLines = KnapcodeOilField.Helpers.PointsToLines1(context.Centers, false)
      for i = 0, #allLines - 1 do
        local continue
        repeat
          local line = allLines:get(i)
          local connections = ListTerminalPair()

          for _, tA in System.each(context.CenterToTerminals:get(line.A)) do
            local continue
            repeat
              for _, tB in System.each(context.CenterToTerminals:get(line.B)) do
                local continue
                repeat
                  if tA.Terminal.X ~= tB.Terminal.X and tA.Terminal.Y ~= tB.Terminal.Y then
                    continue = true
                    break
                  end

                  local straightLine = KnapcodeOilField.Helpers.MakeStraightLineOnEmpty(context.Grid, tA.Terminal, tB.Terminal)
                  if straightLine == nil then
                    continue = true
                    break
                  end

                  connections:Add(class.TerminalPair(tA, tB, straightLine, middle))
                  continue = true
                until 1
                if not continue then
                  break
                end
              end
              continue = true
            until 1
            if not continue then
              break
            end
          end

          if #connections == 0 then
            continue = true
            break
          end

          lines:Add(class.PumpjackConnection(KnapcodeOilField.Endpoints(line.A, line.B), connections, middle))
          continue = true
        until 1
        if not continue then
          break
        end
      end

      -- GENERATE GROUPS
      local groups = ListGroup()
      local addedPumpjacks = ListTerminalLocation()
      local leftoverPumpjacks = KnapcodeFactorioTools.SetHandling.ToSet(context.Centers, context, true)
      while #lines > 0 do
        local line = GetNextLine(lines, addedPumpjacks)

        local addedA = KnapcodeFactorioTools.CollectionExtensions.FirstOrDefault(addedPumpjacks, function (x)
          return KnapcodeOilField.Location.op_Equality(x.Center, line.Endpoints.A)
        end, KnapcodeOilField.TerminalLocation)
        local addedB = KnapcodeFactorioTools.CollectionExtensions.FirstOrDefault(addedPumpjacks, function (x)
          return KnapcodeOilField.Location.op_Equality(x.Center, line.Endpoints.B)
        end, KnapcodeOilField.TerminalLocation)

        line.Connections:Sort(function (a, b)
          local c = System.Int32.CompareTo(a.CenterDistance, b.CenterDistance)
          if c ~= 0 then
            return c
          end

          return System.Int32.CompareTo((#a.Line), #b.Line)
        end)

        for _, connection in System.each(line.Connections) do
          if addedA == nil and addedB == nil then
            local default = ListListLocation()
            default:Add(connection.Line)
            local group = System.new(class.Group, 2, context, connection, default)
            groups:Add(group)
            addedPumpjacks:Add(connection.TerminalA)
            addedPumpjacks:Add(connection.TerminalB)
            leftoverPumpjacks:Remove(connection.TerminalA.Center)
            leftoverPumpjacks:Remove(connection.TerminalB.Center)
            break
          end

          if addedA == nil and addedB ~= nil and addedB.Direction == connection.TerminalB.Direction then
            local group = KnapcodeFactorioTools.CollectionExtensions.First1(groups, function (g)
              return g:HasTerminal(addedB)
            end, class.Group)
            group:Add(connection.TerminalA)
            group.Paths:Add(connection.Line)
            addedPumpjacks:Add(connection.TerminalA)
            leftoverPumpjacks:Remove(connection.TerminalA.Center)
            break
          end

          if addedA ~= nil and addedB == nil and addedA.Direction == connection.TerminalA.Direction then
            local group = KnapcodeFactorioTools.CollectionExtensions.First1(groups, function (g)
              return g:HasTerminal(addedA)
            end, class.Group)
            group:Add(connection.TerminalB)
            group.Paths:Add(connection.Line)
            addedPumpjacks:Add(connection.TerminalB)
            leftoverPumpjacks:Remove(connection.TerminalB.Center)
            break
          end
        end
      end

      -- if no LINES were generated, add 2 pumpjacks to a group here
      -- this will only happen when only a few pumpjacks need to be connected
      if #groups == 0 then
        local connection = nil
        for i = 0, #allLines - 1 do
          local continue
          repeat
            local line = allLines:get(i)
            local terminalsA = context.CenterToTerminals:get(line.A)
            for j = 0, #terminalsA - 1 do
              local continue
              repeat
                local tA = terminalsA:get(j)
                local terminalsB = context.CenterToTerminals:get(line.B)
                for k = 0, #terminalsB - 1 do
                  local continue
                  repeat
                    local tB = terminalsB:get(k)
                    local goals = context:GetSingleLocationSet(tB.Terminal)

                    if connection ~= nil then
                      -- don't perform a shortest path search if the Manhattan distance (minimum possible) is longer than the best.
                      local minDistance = tA.Terminal:GetManhattanDistance(tB.Terminal)
                      if minDistance >= #connection.Line then
                        continue = true
                        break
                      end
                    end

                    local result = KnapcodeOilField.AStar.GetShortestPath(context, context.Grid, tA.Terminal, goals, true, 1, 1)

                    if not result.Success then
                      System.throw(KnapcodeFactorioTools.FactorioToolsException("A goal should have been reached."))
                    end

                    if connection == nil then
                      connection = class.TerminalPair(tA, tB, result:getPath(), middle)
                      continue = true
                      break
                    end

                    local c = System.Int32.CompareTo((#result:getPath()), #connection.Line)
                    if c < 0 then
                      connection = class.TerminalPair(tA, tB, result:getPath(), middle)
                    end
                    continue = true
                  until 1
                  if not continue then
                    break
                  end
                end
                continue = true
              until 1
              if not continue then
                break
              end
            end
            continue = true
          until 1
          if not continue then
            break
          end
        end

        if connection == nil then
          System.throw(KnapcodeFactorioTools.FactorioToolsException("A connection between terminals should have been found."))
        end

        local default = ListListLocation()
        default:Add(connection.Line)
        local group = System.new(class.Group, 2, context, connection, default)
        groups:Add(group)
      end

      -- CONNECT GROUPS
      local maxTries = (strategy == 0 --[[PipeStrategy.FbeOriginal]]) and 3 or 10
      local tries = maxTries
      local aloneGroups = ListGroup()
      local finalGroup = nil

      while #groups > 0 do
        local continue
        repeat
          local group = KnapcodeFactorioTools.CollectionExtensions.MinBy(groups, function (x)
            return KnapcodeFactorioTools.CollectionExtensions.Sum(x.Paths, function (p)
              return #p
            end, ListLocation)
          end, class.Group, System.Int32)
          groups:Remove(group)

          if #groups == 0 then
            if #aloneGroups > 0 and tries > 0 then
              groups:AddRange(aloneGroups)
              groups:Add(group)
              aloneGroups:Clear()
              tries = tries - 1
              continue = true
              break
            end

            finalGroup = group
            break
          end

          local locationToGroup = KnapcodeFactorioTools.SetHandling.ToDictionary(groups, context, function (x)
            return x.Location
          end, function (x)
            return x
          end, class.Group, class.Group)
          locationToGroup:Add(group.Location, group)

          local groupLines = KnapcodeOilField.Helpers.PointsToLines(locationToGroup:getKeys())
          local par = ListGroup(#groupLines)
          for i = 0, #groupLines - 1 do
            local line = groupLines:get(i)
            if KnapcodeOilField.Location.op_Equality(line.A, group.Location) then
              par:Add(locationToGroup:get(line.B))
            elseif KnapcodeOilField.Location.op_Equality(line.B, group.Location) then
              par:Add(locationToGroup:get(line.A))
            end
          end

          local connection = GetPathBetweenGroups(context, par, group, 2 + maxTries - tries, strategy)

          if connection ~= nil then
            connection.FirstGroup:AddRange(group)
            connection.FirstGroup.Paths:AddRange(group.Paths)
            connection.FirstGroup.Paths:Add(connection.Lines:get(0))
          else
            aloneGroups:Add(group)
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      if finalGroup == nil then
        System.throw(KnapcodeFactorioTools.FactorioToolsException("The final group should be initialized at this point."))
      end

      if #aloneGroups > 0 then
        -- Fallback to the modified FBE algorithm if the original cannot connect all of the groups.
        -- Related to https://github.com/teoxoy/factorio-blueprint-editor/issues/254
        if strategy == 0 --[[PipeStrategy.FbeOriginal]] then
          return DelaunayTriangulation(context, middle, 1 --[[PipeStrategy.Fbe]])
        end

        System.throw(KnapcodeFactorioTools.FactorioToolsException("There should be no more alone groups at this point."))
      end


      local sortedLeftoverPumpjacks = ArrayLocation(leftoverPumpjacks:getCount())
      leftoverPumpjacks:CopyTo(SpanLocation.ctorArray(sortedLeftoverPumpjacks))
      System.Array.Sort(sortedLeftoverPumpjacks, function (a, b)
        local aC = a:GetManhattanDistance(middle)
        local bC = b:GetManhattanDistance(middle)
        return System.Int32.CompareTo(aC, bC)
      end)


      for i = 0, #sortedLeftoverPumpjacks - 1 do
        local continue
        repeat
          local center = sortedLeftoverPumpjacks:get(i)
          local centerTerminals = context.CenterToTerminals:get(center)
          local terminalGroups = ListGroup(#centerTerminals)
          for j = 0, #centerTerminals - 1 do
            local terminal = centerTerminals:get(j)
            local default = ListListLocation()
            local extern = ListLocation()
            extern:Add(terminal.Terminal)
            default:Add(extern)
            local group = class.Group(context, terminal, default)
            terminalGroups:Add(group)
          end

          local maxTurns = 2
          while true do
            local continue
            repeat
              local connection = GetPathBetweenGroups(context, terminalGroups, finalGroup, maxTurns, strategy)

              if connection == nil then
                -- Allow more max turns with the modified FBE algorithm.
                -- Related to https://github.com/teoxoy/factorio-blueprint-editor/issues/253
                if strategy == 0 --[[PipeStrategy.FbeOriginal]] then
                  return DelaunayTriangulation(context, middle, 1 --[[PipeStrategy.Fbe]])
                elseif strategy == 0 --[[PipeStrategy.FbeOriginal]] or maxTurns > 4 then
                  System.throw(KnapcodeFactorioTools.FactorioToolsException("There should be at least one connection between a leftover pumpjack and the final group. Max turns: " .. maxTurns))
                end

                maxTurns = maxTurns + 1
                continue = true
                break
              end

              finalGroup:Add(KnapcodeFactorioTools.CollectionExtensions.Single(connection.FirstGroup:getEntities(), KnapcodeOilField.TerminalLocation))
              finalGroup.Paths:Add(connection.Lines:get(0))
              break
            until 1
            if not continue then
              break
            end
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      local terminals = finalGroup:getEntities()
      local pipes = context:GetLocationSet2(true)
      for i = 0, #finalGroup.Paths - 1 do
        local path = finalGroup.Paths:get(i)
        for j = 0, #path - 1 do
          pipes:Add(path:get(j))
        end
      end

      return System.ValueTuple(terminals, pipes, strategy)
    end
    GetNextLine = function (lines, addedPumpjacks)
      local next = nil
      local nextIndex = 0
      local nextContainsAddedPumpjack = nil
      local nextAverageDistance = nil

      for i = 0, #lines - 1 do
        local continue
        repeat
          local line = lines:get(i)
          if next == nil then
            next = line
            continue = true
            break
          end

          if not (nextContainsAddedPumpjack ~= nil) then
            nextContainsAddedPumpjack = LineContainsAnAddedPumpjack(addedPumpjacks, next)
          end

          local containsAddedPumpjack = LineContainsAnAddedPumpjack(addedPumpjacks, line)
          local c = System.Boolean.CompareTo(containsAddedPumpjack, System.Nullable.Value(nextContainsAddedPumpjack))
          if c > 0 then
            next = line
            nextIndex = i
            nextContainsAddedPumpjack = containsAddedPumpjack
            nextAverageDistance = nil
            continue = true
            break
          elseif c < 0 then
            continue = true
            break
          end

          c = System.Int32.CompareTo(line.EndpointDistance, next.EndpointDistance)
          if c > 0 then
            next = line
            nextIndex = i
            nextContainsAddedPumpjack = containsAddedPumpjack
            nextAverageDistance = nil
            continue = true
            break
          elseif c < 0 then
            continue = true
            break
          end

          c = System.Int32.CompareTo((#line.Connections), #next.Connections)
          if c < 0 then
            next = line
            nextIndex = i
            nextContainsAddedPumpjack = containsAddedPumpjack
            nextAverageDistance = nil
            continue = true
            break
          elseif c > 0 then
            continue = true
            break
          end

          if not (nextAverageDistance ~= nil) then
            nextAverageDistance = next:GetAverageDistance()
          end

          local averageDistance = line:GetAverageDistance()
          c = System.Double.CompareToObj(averageDistance, nextAverageDistance)
          if c < 0 then
            next = line
            nextIndex = i
            nextContainsAddedPumpjack = containsAddedPumpjack
            nextAverageDistance = averageDistance
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      lines:RemoveAt(nextIndex)

      return next
    end
    LineContainsAnAddedPumpjack = function (addedPumpjacks, ent)
      for i = 0, #addedPumpjacks - 1 do
        local continue
        repeat
          local terminal = addedPumpjacks:get(i)
          if KnapcodeOilField.Location.op_Inequality(ent.Endpoints.A, terminal.Center) and KnapcodeOilField.Location.op_Inequality(ent.Endpoints.B, terminal.Center) then
            continue = true
            break
          end

          for j = 0, #ent.Connections - 1 do
            local pair = ent.Connections:get(j)
            if pair.TerminalA.Direction == terminal.Direction or pair.TerminalB.Direction == terminal.Direction then
              return true
            end
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      return false
    end
    GetPathBetweenGroups = function (context, groups, group, maxTurns, strategy)
      local best = nil
      for i = 0, #groups - 1 do
        local continue
        repeat
          local g = groups:get(i)
          local connection = ConnectTwoGroups(context, g, group, maxTurns, strategy)
          if #connection.Lines == 0 then
            continue = true
            break
          end

          if best == nil then
            best = connection
            continue = true
            break
          end

          local c = System.Int32.CompareTo(connection.MinDistance, best.MinDistance)
          if c < 0 then
            best = connection
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      return best
    end
    ConnectTwoGroups = function (context, a, b, maxTurns, strategy)
      local aLocations = ListLocation()
      for i = 0, #a.Paths - 1 do
        aLocations:AddRange(a.Paths:get(i))
      end

      local bLocations = ListLocation()
      for i = 0, #b.Paths - 1 do
        bLocations:AddRange(b.Paths:get(i))
      end

      local lineInfo = ListPathAndTurns()
      for i = 0, #aLocations - 1 do
        local continue
        repeat
          local al = aLocations:get(i)
          for j = 0, #bLocations - 1 do
            local continue
            repeat
              local bl = bLocations:get(j)
              if al.X ~= bl.X and al.Y ~= bl.Y then
                continue = true
                break
              end

              local line = KnapcodeOilField.Helpers.MakeStraightLineOnEmpty(context.Grid, al, bl)
              if line == nil then
                continue = true
                break
              end

              lineInfo:Add(class.PathAndTurns(KnapcodeOilField.Endpoints(line:get(0), line:get(#line - 1)), line, 0, #lineInfo))
              continue = true
            until 1
            if not continue then
              break
            end
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      if #aLocations == 1 then
        local locationToIndex = context:GetLocationDictionary1(#bLocations, System.Int32)
        for i = 0, #bLocations - 1 do
          locationToIndex:TryAdd(bLocations:get(i), i)
        end

        bLocations:Sort(function (a, b)
          local aC = aLocations:get(0):GetManhattanDistance(a)
          local bC = aLocations:get(0):GetManhattanDistance(b)
          local c = System.Int32.CompareTo(aC, bC)
          if c ~= 0 then
            return c
          end

          return System.Int32.CompareTo(locationToIndex:get(a), locationToIndex:get(b))
        end)

        if #bLocations > 20 then
          bLocations:RemoveRange(20, #bLocations - 20)
        end
      end

      local aPlusB = context:GetLocationSet6(#aLocations + #bLocations, true)
      aPlusB:UnionWith(aLocations)
      aPlusB:UnionWith(bLocations)

      local allEndpoints = KnapcodeOilField.Helpers.PointsToLines(aPlusB:EnumerateItems())
      local matches = ListTuple(#allEndpoints)
      for i = 0, #allEndpoints - 1 do
        local continue
        repeat
          local pair = allEndpoints:get(i)
          if (aLocations:Contains(pair.A) and aLocations:Contains(pair.B)) or (bLocations:Contains(pair.A) and bLocations:Contains(pair.B)) then
            continue = true
            break
          end

          matches:Add(System.Tuple(pair, pair.A:GetManhattanDistance(pair.B), #matches))
          continue = true
        until 1
        if not continue then
          break
        end
      end

      matches:Sort(function (a, b)
        local c = System.Int32.CompareTo(a[2], b[2])
        if c ~= 0 then
          return c
        end

        return System.Int32.CompareTo(a[3], b[3])
      end)

      local takeLines = math.Min(#matches, 5)
      for i = 0, takeLines - 1 do
        local continue
        repeat
          local l = matches:get(i)[1]

          local path
          if strategy == 0 --[[PipeStrategy.FbeOriginal]] then
            -- We can't terminal early based on max turns because this leads to different results since it allows
            -- secondary path options that would have otherwise been not considered for a given start and goal state.
            path = KnapcodeOilField.BreadthFirstFinder.GetShortestPath(context, l.B, l.A)
            if path == nil then
              -- Visualizer.Show(context.Grid, new[] { l.A, l.B }.Select(p => (IPoint)new Point(p.X, p.Y)), Array.Empty<IEdge>());
              System.throw(KnapcodeFactorioTools.NoPathBetweenTerminalsException(l.A, l.B))
            end
          else
            local goals = context:GetSingleLocationSet(l.B)
            local result = KnapcodeOilField.AStar.GetShortestPath(context, context.Grid, l.A, goals, true, 1, 1)
            if not result.Success then
              -- Visualizer.Show(context.Grid, new[] { l.A, l.B }.Select(p => (IPoint)new Point(p.X, p.Y)), Array.Empty<IEdge>());
              System.throw(KnapcodeFactorioTools.NoPathBetweenTerminalsException(l.A, l.B))
            end

            path = result:getPath()
          end

          local turns = KnapcodeOilField.Helpers.CountTurns(path)
          if turns == 0 or turns > maxTurns then
            continue = true
            break
          end

          lineInfo:Add(class.PathAndTurns(l, path, turns, #lineInfo))
          continue = true
        until 1
        if not continue then
          break
        end
      end

      lineInfo:Sort(function (a, b)
        local c = System.Int32.CompareTo((#a.Path), #b.Path)
        if c ~= 0 then
          return c
        end

        return System.Int32.CompareTo(a.OriginalIndex, b.OriginalIndex)
      end)

      local lines = ListListLocation(#lineInfo)
      local minCount = (#lineInfo == 0) and 0 or 2147483647 --[[Int32.MaxValue]]
      for i = 0, #lineInfo - 1 do
        local path = lineInfo:get(i).Path
        lines:Add(path)
        if #path < minCount then
          minCount = #path
        end
      end

      return class.TwoConnectedGroups(lines, minCount, a)
    end
    GetConnectedPumpjacks = function (context, strategy)
      local centers = context.Centers

      if #centers == 2 then
        local simpleConnectedCenters = context:GetLocationDictionary(KnapcodeOilField.ILocationSet)
        simpleConnectedCenters:Add(centers:get(0), context:GetSingleLocationSet(centers:get(1)))
        simpleConnectedCenters:Add(centers:get(1), context:GetSingleLocationSet(centers:get(0)))
        return simpleConnectedCenters
      end

      -- Check that nodes are not collinear
      if KnapcodeOilField.Helpers.AreLocationsCollinear(centers) then
        local connected = KnapcodeFactorioTools.SetHandling.ToDictionary(centers, context, function (c)
          return c
        end, function (c)
          return context:GetLocationSet2(true)
        end, KnapcodeOilField.Location, KnapcodeOilField.ILocationSet)
        for j = 1, #centers - 1 do
          connected:get(centers:get(j - 1)):Add(centers:get(j))
          connected:get(centers:get(j)):Add(centers:get(j - 1))
        end

        return connected
      end

      local default
      local extern = strategy
      if extern == 2 --[[PipeStrategy.ConnectedCentersDelaunay]] then
        default = GetConnectedPumpjacksWithDelaunay(context, centers)
      elseif extern == 3 --[[PipeStrategy.ConnectedCentersDelaunayMst]] then
        default = GetConnectedPumpjacksWithDelaunayMst(context, centers)
      elseif extern == 4 --[[PipeStrategy.ConnectedCentersFlute]] then
        default = GetConnectedPumpjacksWithFLUTE(context)
      else
        default = System.throw(System.NotImplementedException())
      end
      local connectedCenters = default

      -- check if all connected centers have edges in both directions
      if context.Options.ValidateSolution then
        for _, ref in System.each(connectedCenters:EnumeratePairs()) do
          local center, others = ref:Deconstruct()
          for _, other in System.each(others:EnumerateItems()) do
            if not connectedCenters:get(other):Contains(center) then
              System.throw(KnapcodeFactorioTools.FactorioToolsException("The edges in the connected centers graph are not bidirectional."))
            end
          end
        end
      end

      -- VisualizeConnectedCenters(context, connectedCenters);

      return connectedCenters
    end
    FindTrunksAndConnect = function (context, centerToConnectedCenters)
      local selectedTrunks = FindTrunks(context, centerToConnectedCenters)

      local allIncludedCenters = context:GetLocationSet5(#selectedTrunks * 2)
      for i = 0, #selectedTrunks - 1 do
        for _, center in System.each(selectedTrunks:get(i).Centers:EnumerateItems()) do
          allIncludedCenters:Add(center)
        end
      end

      local groups = ListPumpjackGroup(#selectedTrunks)
      for i = 0, #selectedTrunks - 1 do
        groups:Add(class.PumpjackGroup(context, centerToConnectedCenters, allIncludedCenters, selectedTrunks:get(i)))
      end

      if #groups == 0 then
        local group = ConnectTwoClosestPumpjacks(context, centerToConnectedCenters, allIncludedCenters)

        groups:Add(group)
      end

      --[[
        var clone = new PipeGrid(context.Grid);
        Visualizer.Show(clone, groups.SelectMany(g => g.Pipes).Distinct(context).Select(p => (IPoint)new Point(p.X, p.Y)), Array.Empty<IEdge>());
        ]]

      while #groups > 1 or groups:get(0).IncludedCenters:getCount() < context.CenterToTerminals:getCount() do
        local continue
        repeat
          local shortestDistance = nil
          local candidate = nil

          for _, group in System.each(groups) do
            local continue
            repeat
              local centroidX = KnapcodeFactorioTools.CollectionExtensions.Average(group.Pipes:EnumerateItems(), function (l)
                return l.X
              end, KnapcodeOilField.Location)
              local centroidY = KnapcodeFactorioTools.CollectionExtensions.Average(group.Pipes:EnumerateItems(), function (l)
                return l.Y
              end, KnapcodeOilField.Location)

              for _, center in System.each(group.FrontierCenters:EnumerateItems()) do
                local continue
                repeat
                  local includedCenter = KnapcodeFactorioTools.CollectionExtensions.First1(group.IncludedCenterToChildCenters:EnumeratePairs(), function (p)
                    return p[2]:Contains(center)
                  end, KeyValuePairLocationILocationSet)[1]

                  -- Prefer the terminal that has the shortest path, then prefer the terminal closer to the centroid
                  -- of the child (unconnected) pumpjacks.
                  for _, terminal in System.each(context.CenterToTerminals:get(center)) do
                    local continue
                    repeat
                      local path = GetShortestPathToGroup(context, terminal, group, centroidX, centroidY)

                      if candidate == nil then
                        candidate = class.GroupCandidate(group, center, includedCenter, terminal, path)
                        continue = true
                        break
                      end

                      local comparison = System.Int32.CompareTo((#path), #candidate.Path)
                      if comparison < 0 then
                        candidate = class.GroupCandidate(group, center, includedCenter, terminal, path)
                        shortestDistance = nil
                        continue = true
                        break
                      end

                      if comparison > 0 then
                        continue = true
                        break
                      end

                      if not (shortestDistance ~= nil) then
                        shortestDistance = candidate.Group:GetChildCentroidDistanceSquared(candidate.IncludedCenter, candidate.Terminal.Terminal)
                      end

                      local distance = group:GetChildCentroidDistanceSquared(includedCenter, terminal.Terminal)
                      comparison = System.Double.CompareTo(distance, System.Nullable.Value(shortestDistance))
                      if comparison < 0 then
                        candidate = class.GroupCandidate(group, center, includedCenter, terminal, path)
                        shortestDistance = distance
                      end
                      continue = true
                    until 1
                    if not continue then
                      break
                    end
                  end
                  continue = true
                until 1
                if not continue then
                  break
                end
              end
              continue = true
            until 1
            if not continue then
              break
            end
          end

          if candidate == nil then
            System.throw(KnapcodeFactorioTools.FactorioToolsException("No group candidate was found."))
          end

          if allIncludedCenters:Contains(candidate.Terminal.Center) then
            local otherGroup = KnapcodeFactorioTools.CollectionExtensions.Single1(groups, function (g)
              return g.IncludedCenters:Contains(candidate.Terminal.Center)
            end, class.PumpjackGroup)
            candidate.Group:MergeGroup(otherGroup, candidate.Path)
            groups:Remove(otherGroup)

            --[[
                var clone2 = new PipeGrid(context.Grid);
                AddPipeEntities.Execute(clone2, new(), context.CenterToTerminals, groups.SelectMany(g => g.Pipes).ToSet(), allowMultipleTerminals: true);
                Visualizer.Show(clone2, path.Select(p => (IPoint)new Point(p.X, p.Y)), Array.Empty<IEdge>());
                ]]
          else
            -- Add the newly connected pumpjack to the current group.
            candidate.Group:ConnectPumpjack(candidate.Center, candidate.Path)
            KnapcodeOilField.Helpers.EliminateOtherTerminals(context, candidate.Terminal)

            --[[
                var clone2 = new PipeGrid(context.Grid);
                AddPipeEntities.Execute(clone2, new(), context.CenterToTerminals, groups.SelectMany(g => g.Pipes).ToSet(), allowMultipleTerminals: true);
                Visualizer.Show(clone2, path.Select(p => (IPoint)new Point(p.X, p.Y)), Array.Empty<IEdge>());
                ]]
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      return KnapcodeFactorioTools.CollectionExtensions.Single(groups, class.PumpjackGroup).Pipes
    end
    GetShortestPathToGroup = function (context, terminal, group, groupCentroidX, groupCentroidY)
      local default, extern = System.try(function ()
        local aStarResultV = KnapcodeOilField.AStar.GetShortestPath(context, context.Grid, terminal.Terminal, group.Pipes, true, 2, 1)
        local aStarResultH = KnapcodeOilField.AStar.GetShortestPath(context, context.Grid, terminal.Terminal, group.Pipes, true, 1, 2)


        if not aStarResultV.Success then
          System.throw(KnapcodeFactorioTools.NoPathBetweenTerminalsException(terminal.Terminal, KnapcodeFactorioTools.CollectionExtensions.First(group.Pipes:EnumerateItems(), KnapcodeOilField.Location)))
        end

        if KnapcodeFactorioTools.CollectionExtensions.SequenceEqual(aStarResultV:getPath(), aStarResultH:getPath(), KnapcodeOilField.Location) then
          return true, KnapcodeFactorioTools.CollectionExtensions.ToList(aStarResultV:getPath(), KnapcodeOilField.Location)
        end

        local adjacentPipesV = 0
        local centroidDistanceSquaredV = 0

        local adjacentPipesH = 0
        local centroidDistanceSquaredH = 0

        local sizeEstimate = #aStarResultV:getPath() + #aStarResultH:getPath()

        local locationToCentroidDistanceSquared = context:GetLocationDictionary1(sizeEstimate, System.Double)


        System.try(function ()
          local width = context.Grid.Width
          do
            local i = 0
            while i < math.Max(#aStarResultV:getPath(), #aStarResultH:getPath()) do
              if i < #aStarResultV:getPath() then
                local location = aStarResultV:getPath():get(i)
                if context.LocationToAdjacentCount:get(location.Y * width + location.X) > 0 then
                  adjacentPipesV = adjacentPipesV + 1
                end

                centroidDistanceSquaredV = centroidDistanceSquaredV + GetCentroidDistanceSquared(groupCentroidX, groupCentroidY, locationToCentroidDistanceSquared, location)
              end

              if i < #aStarResultH:getPath() then
                local location = aStarResultH:getPath():get(i)
                if context.LocationToAdjacentCount:get(location.Y * width + location.X) > 0 then
                  adjacentPipesH = adjacentPipesH + 1
                end

                centroidDistanceSquaredH = centroidDistanceSquaredH + GetCentroidDistanceSquared(groupCentroidX, groupCentroidY, locationToCentroidDistanceSquared, location)
              end
              i = i + 1
            end
          end
        end, nil, function ()
        end)

        if adjacentPipesV > adjacentPipesH then
          return true, KnapcodeFactorioTools.CollectionExtensions.ToList(aStarResultV:getPath(), KnapcodeOilField.Location)
        elseif adjacentPipesV < adjacentPipesH then
          return true, KnapcodeFactorioTools.CollectionExtensions.ToList(aStarResultH:getPath(), KnapcodeOilField.Location)
        elseif centroidDistanceSquaredV < centroidDistanceSquaredH then
          return true, KnapcodeFactorioTools.CollectionExtensions.ToList(aStarResultV:getPath(), KnapcodeOilField.Location)
        else
          return true, KnapcodeFactorioTools.CollectionExtensions.ToList(aStarResultH:getPath(), KnapcodeOilField.Location)
        end
      end, nil, function ()
      end)
      if default then
        return extern
      end
    end
    GetCentroidDistanceSquared = function (groupCentroidX, groupCentroidY, locationToCentroidDistanceSquared, location)
      local default, centroidDistanceSquared = locationToCentroidDistanceSquared:TryGetValue(location)
      if not default then
        centroidDistanceSquared = location:GetEuclideanDistanceSquared2(groupCentroidX, groupCentroidY)
        locationToCentroidDistanceSquared:Add(location, centroidDistanceSquared)
      end

      return centroidDistanceSquared
    end
    FindTrunks = function (context, centerToConnectedCenters)
      --[[
        Visualizer.Show(context.Grid, Array.Empty<IPoint>(), centerToConnectedCenters
            .SelectMany(p => p.Value.Select(o => (p.Key, o))
            .Select(p => (IEdge)new Edge(0, new Point(p.Key.X, p.Key.Y), new Point(p.o.X, p.o.Y)))
            .Distinct()));
        ]]

      local trunkCandidates = GetTrunkCandidates(context, centerToConnectedCenters)

      trunkCandidates:Sort(function (a, b)
        local c = System.Int32.CompareTo(b.TerminalLocations:getCount(), a.TerminalLocations:getCount())
        if c ~= 0 then
          return c
        end

        c = System.Int32.CompareTo(a:getLength(), b:getLength())
        if c ~= 0 then
          return c
        end

        local aC = a:GetTrunkEndDistance(centerToConnectedCenters)
        local bC = b:GetTrunkEndDistance(centerToConnectedCenters)
        c = System.Double.CompareTo(aC, bC)
        if c ~= 0 then
          return c
        end

        return System.Int32.CompareTo(a.OriginalIndex, b.OriginalIndex)
      end)

      -- Eliminate lower priority trunks that have any pipes shared with higher priority trunks.
      local includedPipes = context:GetLocationSet1()
      local includedCenters = context:GetLocationSet2(true)
      local selectedTrunks = ListTrunk()
      for _, trunk in System.each(trunkCandidates) do
        local path = KnapcodeOilField.Helpers.MakeStraightLine(trunk:getStart(), trunk:getEnd())
        if not includedPipes:Overlaps(path) and not includedCenters:Overlaps(trunk.Centers:EnumerateItems()) then
          selectedTrunks:Add(trunk)
          includedPipes:UnionWith(path)
          includedCenters:UnionWith1(trunk.Centers)
        end
      end

      --[[
        for (var i = 1; i <= selectedTrunks.Count; i++)
        {
            Visualizer.Show(context.Grid, selectedTrunks.Take(i).SelectMany(t => t.Centers).Distinct(context).Select(l => (IPoint)new Point(l.X, l.Y)), selectedTrunks
                .Take(i)
                .Select(t => (IEdge)new Edge(0, new Point(t.Start.X, t.Start.Y), new Point(t.End.X, t.End.Y)))
                .ToList());
        }
        ]]

      -- Eliminate unused terminals for pumpjacks included in all of the trunks. A pumpjack connected to a trunk has
      -- its terminal selected.
      for _, trunk in System.each(selectedTrunks) do
        for _, terminal in System.each(trunk.Terminals) do
          KnapcodeOilField.Helpers.EliminateOtherTerminals(context, terminal)
        end
      end

      -- Visualize(context, locationToPoint, selectedTrunks.SelectMany(t => MakeStraightLine(t.Start, t.End)).ToSet());

      -- Find the "child" unconnected pumpjacks of each connected pumpjack. These are pumpjacks are connected via the
      -- given connected pumpjack.
      return selectedTrunks
    end
    ConnectTwoClosestPumpjacks = function (context, centerToConnectedCenters, allIncludedCenters)
      local centerToGoals = context:GetLocationDictionary(KnapcodeOilField.ILocationSet)
      local bestConnection = nil
      local bestConnectedCentersCount = 0
      local bestOtherConnectedCentersCount = nil
      local bestTerminalDistance = nil
      local bestOtherTerminalDistance = nil

      for i = 0, #context.Centers - 1 do
        local continue
        repeat
          local center = context.Centers:get(i)
          local terminals = context.CenterToTerminals:get(center)

          for j = 0, #terminals - 1 do
            local continue
            repeat
              local terminal = terminals:get(j)
              local connectedCenters = centerToConnectedCenters:get(center)

              for _, otherCenter in System.each(connectedCenters:EnumerateItems()) do
                local continue
                repeat
                  local otherTerminals = context.CenterToTerminals:get(otherCenter)

                  local default, goals = centerToGoals:TryGetValue(otherCenter)
                  if not default then
                    goals = context:GetLocationSet2(true)
                    for k = 0, #otherTerminals - 1 do
                      goals:Add(otherTerminals:get(k).Terminal)
                    end

                    centerToGoals:Add(otherCenter, goals)
                  end

                  local result = KnapcodeOilField.AStar.GetShortestPath(context, context.Grid, terminal.Terminal, goals, true, 1, 1)
                  if not result.Success then
                    System.throw(KnapcodeFactorioTools.NoPathBetweenTerminalsException(terminal.Terminal, KnapcodeFactorioTools.CollectionExtensions.First(goals:EnumerateItems(), KnapcodeOilField.Location)))
                  end

                  local reachedGoal = result.ReachedGoal
                  local closestTerminal = KnapcodeFactorioTools.CollectionExtensions.Single1(otherTerminals, function (t)
                    return KnapcodeOilField.Location.op_Equality(t.Terminal, reachedGoal)
                  end, KnapcodeOilField.TerminalLocation)
                  local path = result:getPath()

                  if bestConnection == nil then
                    bestConnection = class.BestConnection(path, terminal, closestTerminal)
                    bestConnectedCentersCount = connectedCenters:getCount()
                    bestOtherConnectedCentersCount = nil
                    bestTerminalDistance = nil
                    bestOtherTerminalDistance = nil
                    continue = true
                    break
                  end

                  local c = System.Int32.CompareTo((#path), #bestConnection.Path)
                  if c < 0 then
                    bestConnection = class.BestConnection(path, terminal, closestTerminal)
                    bestConnectedCentersCount = connectedCenters:getCount()
                    bestOtherConnectedCentersCount = nil
                    bestTerminalDistance = nil
                    bestOtherTerminalDistance = nil
                    continue = true
                    break
                  elseif c > 0 then
                    continue = true
                    break
                  end

                  c = System.Int32.CompareTo(connectedCenters:getCount(), bestConnectedCentersCount)
                  if c > 0 then
                    bestConnection = class.BestConnection(path, terminal, closestTerminal)
                    bestConnectedCentersCount = connectedCenters:getCount()
                    bestOtherConnectedCentersCount = nil
                    bestTerminalDistance = nil
                    bestOtherTerminalDistance = nil
                    continue = true
                    break
                  elseif c < 0 then
                    continue = true
                    break
                  end

                  if not (bestOtherConnectedCentersCount ~= nil) then
                    bestOtherConnectedCentersCount = centerToConnectedCenters:get(bestConnection.BestTerminal.Center):getCount()
                  end

                  local otherConnectedCentersCount = centerToConnectedCenters:get(otherCenter):getCount()
                  c = System.Int32.CompareTo(otherConnectedCentersCount, System.Nullable.Value(bestOtherConnectedCentersCount))
                  if c > 0 then
                    bestConnection = class.BestConnection(path, terminal, closestTerminal)
                    bestConnectedCentersCount = connectedCenters:getCount()
                    bestOtherConnectedCentersCount = otherConnectedCentersCount
                    bestTerminalDistance = nil
                    bestOtherTerminalDistance = nil
                    continue = true
                    break
                  elseif c < 0 then
                    continue = true
                    break
                  end

                  if not (bestTerminalDistance ~= nil) then
                    bestTerminalDistance = bestConnection.Terminal.Terminal:GetEuclideanDistanceSquared(context.Grid.Middle)
                  end

                  local terminalDistance = terminal.Terminal:GetEuclideanDistance(context.Grid.Middle)
                  c = System.Double.CompareTo(terminalDistance, System.Nullable.Value(bestTerminalDistance))
                  if c < 0 then
                    bestConnection = class.BestConnection(path, terminal, closestTerminal)
                    bestConnectedCentersCount = connectedCenters:getCount()
                    bestOtherConnectedCentersCount = otherConnectedCentersCount
                    bestTerminalDistance = terminalDistance
                    bestOtherTerminalDistance = nil
                    continue = true
                    break
                  elseif c > 0 then
                    continue = true
                    break
                  end

                  if not (bestOtherTerminalDistance ~= nil) then
                    bestOtherTerminalDistance = bestConnection.BestTerminal.Terminal:GetEuclideanDistanceSquared(context.Grid.Middle)
                  end

                  local otherTerminalDistance = closestTerminal.Terminal:GetEuclideanDistance(context.Grid.Middle)
                  c = System.Double.CompareTo(otherTerminalDistance, System.Nullable.Value(bestOtherTerminalDistance))
                  if c < 0 then
                    bestConnection = class.BestConnection(path, terminal, closestTerminal)
                    bestConnectedCentersCount = connectedCenters:getCount()
                    bestOtherConnectedCentersCount = otherConnectedCentersCount
                    bestTerminalDistance = terminalDistance
                    bestOtherTerminalDistance = otherTerminalDistance
                  end
                  continue = true
                until 1
                if not continue then
                  break
                end
              end
              continue = true
            until 1
            if not continue then
              break
            end
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      if bestConnection == nil then
        System.throw(KnapcodeFactorioTools.FactorioToolsException("A new connection should have been found."))
      end

      KnapcodeOilField.Helpers.EliminateOtherTerminals(context, bestConnection.Terminal)
      KnapcodeOilField.Helpers.EliminateOtherTerminals(context, bestConnection.BestTerminal)

      local group = System.new(class.PumpjackGroup, 2, context, centerToConnectedCenters, allIncludedCenters, ArrayLocation(2, {
        bestConnection.Terminal.Center,
        bestConnection.BestTerminal.Center
      }), bestConnection.Path)

      return group
    end
    GetChildCenters = function (context, centerToConnectedCenters, ignoreCenters, shallowExploreCenters, startingCenter)
      local queue = QueueValueTuple()
      local visited = context:GetLocationSet2(true)
      queue:Enqueue(System.ValueTuple(startingCenter, true))

      while #queue > 0 do
        local continue
        repeat
          local current, shouldRecurse = queue:Dequeue():Deconstruct()
          if not visited:Add(current) or not shouldRecurse then
            continue = true
            break
          end

          for _, other in System.each(centerToConnectedCenters:get(current):EnumerateItems()) do
            local continue
            repeat
              if ignoreCenters:Contains(other) then
                continue = true
                break
              end

              -- If the other center is in another group, don't recursively explore.
              queue:Enqueue(System.ValueTuple(other, not shallowExploreCenters:Contains(other)))
              continue = true
            until 1
            if not continue then
              break
            end
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      visited:Remove(startingCenter)
      return visited
    end
    GetTrunkCandidates = function (context, centerToConnectedCenters)
      local centerToMaxX = KnapcodeFactorioTools.SetHandling.ToDictionary(context.Centers, context, function (c)
        return c
      end, function (c)
        return KnapcodeFactorioTools.CollectionExtensions.Max(centerToConnectedCenters:get(c):EnumerateItems(), function (c)
          return KnapcodeFactorioTools.CollectionExtensions.Max(context.CenterToTerminals:get(c), function (t)
            return t.Terminal.X
          end, KnapcodeOilField.TerminalLocation, System.Int32)
        end, KnapcodeOilField.Location, System.Int32)
      end, KnapcodeOilField.Location, System.Int32)
      local centerToMaxY = KnapcodeFactorioTools.SetHandling.ToDictionary(context.Centers, context, function (c)
        return c
      end, function (c)
        return KnapcodeFactorioTools.CollectionExtensions.Max(centerToConnectedCenters:get(c):EnumerateItems(), function (c)
          return KnapcodeFactorioTools.CollectionExtensions.Max(context.CenterToTerminals:get(c), function (t)
            return t.Terminal.Y
          end, KnapcodeOilField.TerminalLocation, System.Int32)
        end, KnapcodeOilField.Location, System.Int32)
      end, KnapcodeOilField.Location, System.Int32)

      -- Find paths that connect the most terminals of neighboring pumpjacks.
      local trunkCandidates = ListTrunk()
      for _, translation in System.each(Translations) do
        for _, startingCenter in System.each(context.Centers) do
          for _, terminal in System.each(context.CenterToTerminals:get(startingCenter)) do
            local currentCenter = startingCenter
            local expandedChildCenters = false
            local nextCenters = centerToConnectedCenters:get(currentCenter)
            local maxX = centerToMaxX:get(currentCenter)
            local maxY = centerToMaxY:get(currentCenter)

            local location = terminal.Terminal:Translate1(translation)

            local trunk = nil

            while location.X <= maxX and location.Y <= maxY and context.Grid:IsEmpty(location) do
              local default, terminals = context.LocationToTerminals:TryGetValue(location)
              if default then
                local nextCenter = KnapcodeOilField.Location.getInvalid()
                local hasMatch = false
                for _, nextTerminal in System.each(terminals) do
                  if nextCenters:Contains(nextTerminal.Center) then
                    nextCenter = nextTerminal.Center
                    hasMatch = true
                    break
                  end
                end

                if not hasMatch then
                  -- The pumpjack terminal we ran into does not belong to the a pumpjack that the current
                  -- pumpjack should be connected to.
                  break
                end

                if not expandedChildCenters then
                  nextCenters = GetChildCenters(context, centerToConnectedCenters, context:GetSingleLocationSet(currentCenter), context:GetSingleLocationSet(nextCenter), nextCenter)

                  if nextCenters:getCount() == 0 then
                    break
                  end

                  maxX = KnapcodeFactorioTools.CollectionExtensions.Max(nextCenters:EnumerateItems(), function (c)
                    return KnapcodeFactorioTools.CollectionExtensions.Max(context.CenterToTerminals:get(c), function (t)
                      return t.Terminal.X
                    end, KnapcodeOilField.TerminalLocation, System.Int32)
                  end, KnapcodeOilField.Location, System.Int32)
                  maxY = KnapcodeFactorioTools.CollectionExtensions.Max(nextCenters:EnumerateItems(), function (c)
                    return KnapcodeFactorioTools.CollectionExtensions.Max(context.CenterToTerminals:get(c), function (t)
                      return t.Terminal.Y
                    end, KnapcodeOilField.TerminalLocation, System.Int32)
                  end, KnapcodeOilField.Location, System.Int32)
                  expandedChildCenters = true
                end

                if trunk == nil then
                  trunk = class.Trunk(context, terminal, currentCenter)
                end

                trunk.Terminals:AddRange(terminals)
                for _, other in System.each(terminals) do
                  trunk.TerminalLocations:Add(other.Terminal)
                end
                for _, nextTerminal in System.each(terminals) do
                  trunk.Centers:Add(nextTerminal.Center)
                end

                currentCenter = nextCenter
              end

              location = location:Translate1(translation)
            end

            if trunk ~= nil and trunk.Centers:getCount() > 1 then
              trunk.OriginalIndex = #trunkCandidates
              trunkCandidates:Add(trunk)
            end
          end
        end
      end

      return trunkCandidates
    end
    GetConnectedPumpjacksWithDelaunay = function (context, centers)
      local delaunator = GetDelauntator(centers)
      local dlGraph = KnapcodeFactorioTools.SetHandling.ToDictionary(centers, context, function (c)
        return c
      end, function (c)
        return context:GetLocationSet2(true)
      end, KnapcodeOilField.Location, KnapcodeOilField.ILocationSet)

      for e = 0, #delaunator.Triangles - 1 do
        if e > delaunator.Halfedges:get(e) then
          local p = centers:get(delaunator.Triangles:get(e))
          local q = centers:get(delaunator.Triangles:get((System.mod(e, 3) == 2) and (e - 2) or (e + 1)))

          dlGraph:get(p):Add(q)
          dlGraph:get(q):Add(p)
        end
      end

      return dlGraph
    end
    GetConnectedPumpjacksWithDelaunayMst = function (context, centers)
      local delaunator = GetDelauntator(centers)
      local dlGraph = KnapcodeFactorioTools.SetHandling.ToDictionary(centers, context, function (c)
        return c
      end, function (c)
        return context:GetLocationDictionary(System.Int32)
      end, KnapcodeOilField.Location, ILocationDictionary_1Int32)

      for e = 0, #delaunator.Triangles - 1 do
        if e > delaunator.Halfedges:get(e) then
          local p = centers:get(delaunator.Triangles:get(e))
          local q = centers:get(delaunator.Triangles:get((System.mod(e, 3) == 2) and (e - 2) or (e + 1)))

          local cost = p:GetEuclideanDistanceSquared(q)
          dlGraph:get(p):set(q, cost)
          dlGraph:get(q):set(p, cost)
        end
      end

      local closestToMiddle = KnapcodeFactorioTools.CollectionExtensions.MinBy(centers, System.fn(context.Grid.Middle, context.Grid.Middle.GetEuclideanDistanceSquared), KnapcodeOilField.Location, System.Int32)
      local mst = KnapcodeOilField.Prims.GetMinimumSpanningTree(context, dlGraph, closestToMiddle, false)

      return mst
    end
    GetDelauntator = function (centers)
      local points = ArrayIPoint(#centers)
      for i = 0, #centers - 1 do
        local center = centers:get(i)
        points:set(i, DelaunatorSharp.Point(center.X, center.Y))
      end
      local delaunator = DelaunatorSharp.Delaunator(points)
      return delaunator
    end
    GetConnectedPumpjacksWithFLUTE = function (context)
      local locationToPoint = GetLocationToFlutePoint(context)

      -- Determine which terminals should be connected to each other either directly or via only Steiner points.
      local centerToCenters = context:GetLocationDictionary(KnapcodeOilField.ILocationSet)
      for _, default in System.each(context.CenterToTerminals:EnumeratePairs()) do
        local center, terminals = default:Deconstruct()
        local continue
        repeat
          local otherCenters = context:GetLocationSet2(true)
          local visitedPoints = context:GetLocationSet1()
          local queue = QueueFlutePoint()
          for _, terminal in System.each(terminals) do
            queue:Enqueue(locationToPoint:get(terminal.Terminal))
          end

          while #queue > 0 do
            local continue
            repeat
              local point = queue:Dequeue()

              if not visitedPoints:Add(point.Location) then
                continue = true
                break
              end

              if not point.Centers:Contains(center) and point.Centers:getCount() > 0 then
                otherCenters:UnionWith1(point.Centers)
              else
                otherCenters:UnionWith1(point.Centers)

                for _, neighbor in System.each(point.Neighbors:EnumerateItems()) do
                  queue:Enqueue(locationToPoint:get(neighbor))
                end
              end
              continue = true
            until 1
            if not continue then
              break
            end
          end

          otherCenters:Remove(center)
          centerToCenters:Add(center, otherCenters)
          continue = true
        until 1
        if not continue then
          break
        end
      end

      return centerToCenters
    end
    GetLocationToFlutePoint = function (context)
      local fluteTree = GetFluteTree(context)

      -- VisualizeFLUTE(context, context.CenterToTerminals.SelectMany(p => p.Value).Select(l => (IPoint)new Point(l.Terminal.X, l.Terminal.Y)), fluteTree);

      -- Map the FLUTE tree into a more useful object graph.
      local locationToPoint = context:GetLocationDictionary(class.FlutePoint)

      local function GetOrAddPoint(locationToPoint, branch) 
        local location = KnapcodeOilField.Location(branch.X, branch.Y)
        local default, point = locationToPoint:TryGetValue(location)
        if not default then
          point = class.FlutePoint(context, location)
          locationToPoint:Add(location, point)
        end

        return point
      end

      -- Explore the branches.
      for _, branch in System.each(fluteTree.Branch) do
        local current = branch:__clone__()
        while true do
          local next = fluteTree.Branch:get(current.N)

          local currentPoint = GetOrAddPoint(locationToPoint, current:__clone__())
          local nextPoint = GetOrAddPoint(locationToPoint, next:__clone__())

          currentPoint.Neighbors:Add(nextPoint.Location)
          nextPoint.Neighbors:Add(currentPoint.Location)

          if current.N == next.N then
            break
          end

          current = next:__clone__()
        end
      end

      -- Remove self from neighbors
      for _, point in System.each(locationToPoint:getValues()) do
        point.Neighbors:Remove(point.Location)
      end

      -- Add in pumpjack information
      for _, default in System.each(context.CenterToTerminals:EnumeratePairs()) do
        local center, terminals = default:Deconstruct()
        for _, terminal in System.each(terminals) do
          local point = locationToPoint:get(terminal.Terminal)
          point.Terminals:Add(terminal)
          point.Centers:Add(center)
        end
      end

      return locationToPoint
    end
    GetFluteTree = function (context)
      --[[
        var centerPoints = context
            .CenterToTerminals
            .Keys
            .Select(l => new System.Drawing.Point(l.X, l.Y))
            .ToList();
        ]]

      local terminalPoints = ListPoint()
      for _, terminals in System.each(context.CenterToTerminals:getValues()) do
        for i = 0, #terminals - 1 do
          local terminal = terminals:get(i)
          terminalPoints:Add(KnapcodeFluteSharp.Point(terminal.Terminal.X, terminal.Terminal.Y))
        end
      end

      --[[
        var pumpjackPoints = context
            .Grid
            .LocationToEntity
            .Where(p => p.Value is PumpjackSide || p.Value is PumpjackCenter)
            .Select(p => p.Key)
            .Select(l => new System.Drawing.Point(l.X, l.Y))
            .ToList();
        ]]

      KnapcodeOilField.InitializeFLUTE.Execute(6)

      return KnapcodeOilField.InitializeFLUTE.FLUTE:Execute(terminalPoints)
    end
    class = {
      Execute = Execute,
      ExecuteWithFbe = ExecuteWithFbe,
      static = static
    }
    return class
  end)
end)
