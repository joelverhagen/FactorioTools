-- Generated by CSharp.lua Compiler
local System = System
local KnapcodeFactorioTools
local KnapcodeOilField
System.import(function (out)
  KnapcodeFactorioTools = Knapcode.FactorioTools
  KnapcodeOilField = Knapcode.FactorioTools.OilField
end)
System.namespace("Knapcode.FactorioTools.OilField", function (namespace)
  namespace.class("PlanUndergroundPipes", function (namespace)
    local Execute, ConvertInOneDirection, AddRunAndClear
    Execute = function (context, pipes)
      -- Track underground pipes and their directions
      local locationToDirection = context:GetLocationDictionary(System.Int32)

      ConvertInOneDirection(context, pipes, locationToDirection, KnapcodeOilField.Location(0, 1))
      ConvertInOneDirection(context, pipes, locationToDirection, KnapcodeOilField.Location(1, 0))

      KnapcodeOilField.Validate.UndergroundPipesArePipes(context, pipes, locationToDirection)

      return locationToDirection
    end
    ConvertInOneDirection = function (context, pipes, locationToDirection, forward)
      local forwardDirection
      local backwardDirection
      local sort

      if forward.X == 1 and forward.Y == 0 then
        forwardDirection = 2 --[[Direction.Right]]
        backwardDirection = 6 --[[Direction.Left]]
        sort = function (a, b)
          local c = System.Int32.CompareTo(a.Y, b.Y)
          if c ~= 0 then
            return c
          end

          return System.Int32.CompareTo(a.X, b.X)
        end
      elseif forward.X == 0 and forward.Y == 1 then
        forwardDirection = 4 --[[Direction.Down]]
        backwardDirection = 0 --[[Direction.Up]]
        sort = function (a, b)
          local c = System.Int32.CompareTo(a.X, b.X)
          if c ~= 0 then
            return c
          end

          return System.Int32.CompareTo(a.Y, b.Y)
        end
      else
        System.throw(System.NotImplementedException())
      end

      -- Find candidates for underground pipes. These are pipes that have other pipes before and after them in
      -- axis they are going and no pipes next to them.


      local candidates = context:GetLocationSet2(true)
      local backward = KnapcodeOilField.Location(forward.X * - 1, forward.Y * - 1)
      local right = KnapcodeOilField.Location(forward.Y, forward.X)
      local left = KnapcodeOilField.Location(right.X * - 1, right.Y * - 1)

      for _, goal in System.each(pipes:EnumerateItems()) do
        local continue
        repeat
          if (pipes:Contains(goal:Translate1(forward)) or pipes:Contains(goal:Translate1(backward))) and not pipes:Contains(goal:Translate1(right)) and not pipes:Contains(goal:Translate1(left)) then
            local default, terminals = context.LocationToTerminals:TryGetValue(goal)
            if default then
              if terminals:getCount() > 1 then
                continue = true
                break
              end

              local direction = terminals:get(0).Direction
              if direction ~= forwardDirection and direction ~= backwardDirection then
                continue = true
                break
              end
            end

            candidates:Add(goal)
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      if candidates:getCount() == 0 then
        return
      end

      local sorted = KnapcodeFactorioTools.CollectionExtensions.ToTableArray(candidates:EnumerateItems(), KnapcodeOilField.Location)
      sorted:Sort(sort)

      local currentRun = KnapcodeOilField.TableArray.New2(sorted:get(0), KnapcodeOilField.Location)
      for i = 1, sorted:getCount() - 1 do
        local continue
        repeat
          local previous = currentRun:get(currentRun:getCount() - 1)
          local current = sorted:get(i)

          if previous.X + forward.X == current.X and previous.Y + forward.Y == current.Y and currentRun:getCount() < 11 --[[PlanUndergroundPipes.MaxUnderground]] then
            currentRun:Add(current)
            continue = true
            break
          end

          AddRunAndClear(pipes, locationToDirection, forwardDirection, backwardDirection, currentRun)

          currentRun:Add(current)
          continue = true
        until 1
        if not continue then
          break
        end
      end

      AddRunAndClear(pipes, locationToDirection, forwardDirection, backwardDirection, currentRun)
    end
    AddRunAndClear = function (pipes, locationToDirection, forwardDirection, backwardDirection, currentRun)
      if currentRun:getCount() >= 3 --[[PlanUndergroundPipes.MinUnderground]] then
        -- Convert pipes to underground pipes
        locationToDirection:Add(currentRun:get(0), backwardDirection)
        locationToDirection:Add(currentRun:get(currentRun:getCount() - 1), forwardDirection)

        for j = 1, currentRun:getCount() - 1 - 1 do
          pipes:Remove(currentRun:get(j))
        end
      end

      currentRun:Clear()
    end
    return {
      Execute = Execute
    }
  end)
end)
