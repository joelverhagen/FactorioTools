-- Generated by CSharp.lua Compiler
local System = System
local KnapcodeOilField
local SpanLocation
local ArrayLocation
local QueueLocation
System.import(function (out)
  KnapcodeOilField = Knapcode.FactorioTools.OilField
  SpanLocation = System.Span(KnapcodeOilField.Location)
  ArrayLocation = System.Array(KnapcodeOilField.Location)
  QueueLocation = System.Queue(KnapcodeOilField.Location)
end)
System.namespace("Knapcode.FactorioTools.OilField", function (namespace)
  namespace.class("BreadthFirstFinder", function (namespace)
    local GetShortestPath
    GetShortestPath = function (context, start, goal)
      local toExplore = QueueLocation()
      local parents = context:GetLocationDictionary(KnapcodeOilField.Location)
      local visited = context:GetLocationSet1()
      toExplore:Enqueue(start)

      local neighbors = SpanLocation.ctorArray(ArrayLocation(4))


      while #toExplore > 0 do
        local continue
        repeat
          local current = toExplore:Dequeue()
          if not visited:Add(current) then
            continue = true
            break
          end

          if KnapcodeOilField.Location.op_Equality(current, goal) then
            local output = KnapcodeOilField.TableArray.New2(current, KnapcodeOilField.Location)
            while true do
              local default, parent = parents:TryGetValue(current)
              if not default then
                break
              end
              output:Add(parent)
              current = parent
            end

            output:Reverse()
            return output
          end

          context.Grid:GetNeighbors(neighbors, current)
          for i = 0, neighbors:getLength() - 1 do
            local continue
            repeat
              local next = neighbors:get(i)
              if not next.IsValid or visited:Contains(next) or not parents:TryAdd(next, current) then
                continue = true
                break
              end

              toExplore:Enqueue(next)
              continue = true
            until 1
            if not continue then
              break
            end
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      return nil
    end
    return {
      GetShortestPath = GetShortestPath
    }
  end)
end)
