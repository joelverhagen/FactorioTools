-- Generated by CSharp.lua Compiler
local System = System
local KnapcodeFactorioTools
local KnapcodeOilField
local KnapcodePlanBeaconsSnug
local ListLocation
local ListProviderRecipient
local KeyValuePairLocationBeaconCandidateInfo
local ListKeyValuePairLocationBeaconCandidateInfo
System.import(function (out)
  KnapcodeFactorioTools = Knapcode.FactorioTools
  KnapcodeOilField = Knapcode.FactorioTools.OilField
  KnapcodePlanBeaconsSnug = Knapcode.FactorioTools.OilField.PlanBeaconsSnug
  ListLocation = System.List(KnapcodeOilField.Location)
  ListProviderRecipient = System.List(KnapcodeOilField.ProviderRecipient)
  KeyValuePairLocationBeaconCandidateInfo = System.KeyValuePair(KnapcodeOilField.Location, KnapcodePlanBeaconsSnug.BeaconCandidateInfo)
  ListKeyValuePairLocationBeaconCandidateInfo = System.List(KeyValuePairLocationBeaconCandidateInfo)
end)
System.namespace("Knapcode.FactorioTools.OilField", function (namespace)
  namespace.class("PlanBeaconsSnug", function (namespace)
    local Execute, PopulateCandidateToInfo, AddNeighborsAndSort, class
    namespace.class("CandidateFactory", function (namespace)
      local Instance, Create, class, static
      static = function (this)
        Instance = class()
        this.Instance = Instance
      end
      Create = function (this, covered)
        return KnapcodePlanBeaconsSnug.BeaconCandidateInfo(covered)
      end
      class = {
        base = function (out)
          return {
            out.Knapcode.FactorioTools.OilField.ICandidateFactory_1(out.Knapcode.FactorioTools.OilField.PlanBeaconsSnug.BeaconCandidateInfo)
          }
        end,
        Create = Create,
        static = static
      }
      return class
    end)
    namespace.class("BeaconCandidateInfo", function (namespace)
      local __ctor__
      __ctor__ = function (this, covered)
        System.base(this).__ctor__(this, covered)
      end
      return {
        base = function (out)
          return {
            out.Knapcode.FactorioTools.OilField.CandidateInfo
          }
        end,
        MiddleDistance = 0,
        CoveredCount = 0,
        __ctor__ = __ctor__
      }
    end)
    namespace.class("SnugCandidateSorter", function (namespace)
      local Instance, Compare, class, static
      static = function (this)
        Instance = class()
        this.Instance = Instance
      end
      Compare = function (this, x, y)
        local c = System.Int32.CompareTo(x[2].Covered.TrueCount, y[2].Covered.TrueCount)
        if c ~= 0 then
          return c
        end

        c = System.Double.CompareTo(x[2].EntityDistance, y[2].EntityDistance)
        if c ~= 0 then
          return c
        end

        return System.Int32.CompareTo(y[2].MiddleDistance, x[2].MiddleDistance)
      end
      class = {
        base = function (out)
          return {
            System.IComparer_1(System.KeyValuePair(out.Knapcode.FactorioTools.OilField.Location, out.Knapcode.FactorioTools.OilField.PlanBeaconsSnug.BeaconCandidateInfo))
          }
        end,
        Compare = Compare,
        static = static
      }
      return class
    end)
    Execute = function (context)
      local poweredEntities = ListProviderRecipient(context.CenterToTerminals:getCount())
      for _, center in System.each(context.Centers) do
        poweredEntities:Add(KnapcodeOilField.ProviderRecipient(center, 3 --[[Helpers.PumpjackWidth]], 3 --[[Helpers.PumpjackHeight]]))
      end

      -- We don't try to remove unused beacons here because there should not be any existing beacons at this point.
      local candidateToInfo, coveredEntities, existingBeacons = KnapcodeOilField.Helpers.GetBeaconCandidateToCovered(context, poweredEntities, class.CandidateFactory.Instance, false, class.BeaconCandidateInfo):Deconstruct()

      KnapcodeOilField.Validate.NoExistingBeacons(context, existingBeacons)

      PopulateCandidateToInfo(context, candidateToInfo, poweredEntities)

      -- Visualizer.Show(context.Grid, candidateToInfo.Keys.Select(l => (DelaunatorSharp.IPoint)new DelaunatorSharp.Point(l.X, l.Y)), Array.Empty<DelaunatorSharp.IEdge>());

      local sorter = class.SnugCandidateSorter()

      local scopedCandidates = ListKeyValuePairLocationBeaconCandidateInfo()
      local scopedCandidatesSet = context:GetLocationDictionary(class.BeaconCandidateInfo)

      local coveredToCandidates = nil
      if not context.Options.OverlapBeacons then
        coveredToCandidates = KnapcodeOilField.Helpers.GetCoveredToCandidates(context, candidateToInfo, coveredEntities, class.BeaconCandidateInfo)
      end

      local beacons = ListLocation()
      local effects = 0

      while candidateToInfo:getCount() > 0 do
        local continue
        repeat
          local pair = KnapcodeFactorioTools.CollectionExtensions.MinBy(candidateToInfo:EnumeratePairs(), function (pair)
            return System.Tuple((#beacons > 0 and context.Options.OverlapBeacons) and KnapcodeFactorioTools.CollectionExtensions.Min(beacons, function (x)
              return x:GetManhattanDistance(pair[1])
            end, KnapcodeOilField.Location, System.Int32) or 0, - pair[2].Covered.TrueCount, - pair[2].EntityDistance, pair[2].MiddleDistance)
          end, KeyValuePairLocationBeaconCandidateInfo, System.Tuple)

          scopedCandidates:Clear()
          scopedCandidates:Add(pair)
          scopedCandidatesSet:Clear()
          scopedCandidatesSet:Add(pair[1], pair[2])

          while #scopedCandidates > 0 do
            local continue
            repeat
              local candidate, info = scopedCandidates:get(#scopedCandidates - 1):Deconstruct()
              scopedCandidates:RemoveAt(#scopedCandidates - 1)

              if not candidateToInfo:ContainsKey(candidate) then
                continue = true
                break
              end

              if context.Options.OverlapBeacons then
                KnapcodeOilField.Helpers.RemoveOverlappingCandidates(context.Grid, candidate, context.Options.BeaconWidth, context.Options.BeaconHeight, candidateToInfo, class.BeaconCandidateInfo)
              else
                KnapcodeOilField.Helpers.AddProviderAndPreventMultipleProviders(context, candidate, info, context.Options.BeaconWidth, context.Options.BeaconHeight, poweredEntities, coveredEntities, coveredToCandidates, candidateToInfo, class.BeaconCandidateInfo)
              end

              beacons:Add(candidate)
              effects = effects + info.CoveredCount
              -- Console.WriteLine($"{candidate} --- {info.CoveredCount}");

              AddNeighborsAndSort(context, candidateToInfo, scopedCandidates, scopedCandidatesSet, sorter, candidate)

              --[[
                var clone = new PipeGrid(context.Grid);
                foreach (var beaconCenter in beacons)
                {
                    AddProvider(clone, beaconCenter, new BeaconCenter(), c => new BeaconSide(c), context.Options.BeaconWidth, context.Options.BeaconHeight);
                }
                Visualizer.Show(
                    clone,
                    candidateToInfo.Keys.Concat(new[] { candidate }).Select(c => (DelaunatorSharp.IPoint)new DelaunatorSharp.Point(c.X, c.Y)),
                    Array.Empty<DelaunatorSharp.IEdge>());
                ]]
              continue = true
            until 1
            if not continue then
              break
            end
          end

          -- Visualizer.Show(context.Grid, candidateToCovered.Keys.Select(l => (DelaunatorSharp.IPoint)new DelaunatorSharp.Point(l.X, l.Y)), Array.Empty<DelaunatorSharp.IEdge>());
          continue = true
        until 1
        if not continue then
          break
        end
      end

      -- Visualizer.Show(context.Grid, Array.Empty<DelaunatorSharp.IPoint>(), Array.Empty<DelaunatorSharp.IEdge>());

      return System.ValueTuple(beacons, effects)
    end
    PopulateCandidateToInfo = function (context, candidateToInfo, poweredEntities)
      for _, default in System.each(candidateToInfo:EnumeratePairs()) do
        local candidate, info = default:Deconstruct()
        info.EntityDistance = KnapcodeOilField.Helpers.GetEntityDistance(poweredEntities, candidate, info.Covered)
        info.MiddleDistance = candidate:GetEuclideanDistanceSquared(context.Grid.Middle)
        info.CoveredCount = info.Covered.TrueCount
      end
    end
    AddNeighborsAndSort = function (context, candidateToInfo, scopedCandidates, scopedCandidatesSet, sorter, candidate)
      local overlapMinX, overlapMinY, overlapMaxX, overlapMaxY = KnapcodeOilField.Helpers.GetProviderOverlapBounds(context.Grid, candidate, context.Options.BeaconWidth, context.Options.BeaconHeight):Deconstruct()

      local minX = math.Max(System.div((context.Options.BeaconWidth - 1), 2), overlapMinX - 1)
      local minY = math.Max(System.div((context.Options.BeaconHeight - 1), 2), overlapMinY - 1)
      local maxX = math.Min(context.Grid.Width - (System.div(context.Options.BeaconWidth, 2)) - 1, overlapMaxX + 1)
      local maxY = math.Min(context.Grid.Height - (System.div(context.Options.BeaconHeight, 2)) - 1, overlapMaxY + 1)

      local initialCount = #scopedCandidates

      -- top bound of the neighbor rectangle
      if overlapMinY - 1 == minY then
        for x = minX, maxX do
          local location = KnapcodeOilField.Location(x, minY)
          local extern, info = candidateToInfo:TryGetValue(location)
          if extern and scopedCandidatesSet:TryAdd(location, info) then
            scopedCandidates:Add(System.KeyValuePair.Create(location, info, KnapcodeOilField.Location, class.BeaconCandidateInfo))
          end
        end
      end

      -- bottom bound of the neighbor rectangle
      if overlapMaxY + 1 == maxY then
        for x = minX, maxX do
          local location = KnapcodeOilField.Location(x, maxY)
          local extern, info = candidateToInfo:TryGetValue(location)
          if extern and scopedCandidatesSet:TryAdd(location, info) then
            scopedCandidates:Add(System.KeyValuePair.Create(location, info, KnapcodeOilField.Location, class.BeaconCandidateInfo))
          end
        end
      end

      -- left bound of the neighbor rectangle, avoiding the corners
      if overlapMinX - 1 == minX then
        for y = minY + 1, maxY - 1 do
          local location = KnapcodeOilField.Location(minX, y)
          local extern, info = candidateToInfo:TryGetValue(location)
          if extern and scopedCandidatesSet:TryAdd(location, info) then
            scopedCandidates:Add(System.KeyValuePair.Create(location, info, KnapcodeOilField.Location, class.BeaconCandidateInfo))
          end
        end
      end

      -- right bound of the neighbor rectangle, avoiding the corners
      if overlapMaxX + 1 == maxX then
        for y = minY + 1, maxY - 1 do
          local location = KnapcodeOilField.Location(maxX, y)
          local extern, info = candidateToInfo:TryGetValue(location)
          if extern and scopedCandidatesSet:TryAdd(location, info) then
            scopedCandidates:Add(System.KeyValuePair.Create(location, info, KnapcodeOilField.Location, class.BeaconCandidateInfo))
          end
        end
      end

      if initialCount < #scopedCandidates then
        scopedCandidates:Sort(initialCount, #scopedCandidates - initialCount, sorter)
      end
    end
    class = {
      Execute = Execute
    }
    return class
  end)
end)
