-- Generated by CSharp.lua Compiler
local System = System
local KnapcodeFluteSharp = Knapcode.FluteSharp
local ListPoint = System.List(KnapcodeFluteSharp.Point)
local KnapcodeOilField
local AddPipesConnectedCentersFLUTE
local QueueFlutePoint
System.import(function (out)
  KnapcodeOilField = Knapcode.FactorioTools.OilField
  AddPipesConnectedCentersFLUTE = Knapcode.FactorioTools.OilField.AddPipesConnectedCentersFLUTE
  QueueFlutePoint = System.Queue(AddPipesConnectedCentersFLUTE.FlutePoint)
end)
System.namespace("Knapcode.FactorioTools.OilField", function (namespace)
  namespace.class("AddPipesConnectedCentersFLUTE", function (namespace)
    local Execute, GetLocationToFlutePoint, GetFluteTree, class
    namespace.class("FlutePoint", function (namespace)
      local getIsSteinerPoint, ToString, __ctor__
      __ctor__ = function (this, context, location)
        this.Terminals = KnapcodeOilField.TableArray.New(KnapcodeOilField.TerminalLocation)
        this.Location = location
        this.Centers = context:GetLocationSet2(true)
        this.Neighbors = context:GetLocationSet2(true)
      end
      getIsSteinerPoint = function (this)
        return this.Centers:getCount() == 0
      end
      ToString = function (this)
        return this.Location:ToString()
      end
      return {
        IsEliminated = false,
        getIsSteinerPoint = getIsSteinerPoint,
        ToString = ToString,
        __ctor__ = __ctor__
      }
    end)
    Execute = function (context)
      local locationToPoint = GetLocationToFlutePoint(context)

      -- Determine which terminals should be connected to each other either directly or via only Steiner points.
      local centerToCenters = context:GetLocationDictionary(KnapcodeOilField.ILocationSet)
      for _, default in System.each(context.CenterToTerminals:EnumeratePairs()) do
        local center, terminals = default:Deconstruct()
        local continue
        repeat
          local otherCenters = context:GetLocationSet2(true)
          local visitedPoints = context:GetLocationSet1()
          local queue = QueueFlutePoint()
          for i = 0, terminals:getCount() - 1 do
            queue:Enqueue(locationToPoint:get(terminals:get(i).Terminal))
          end

          while #queue > 0 do
            local continue
            repeat
              local point = queue:Dequeue()

              if not visitedPoints:Add(point.Location) then
                continue = true
                break
              end

              if not point.Centers:Contains(center) and point.Centers:getCount() > 0 then
                otherCenters:UnionWith1(point.Centers)
              else
                otherCenters:UnionWith1(point.Centers)

                for _, neighbor in System.each(point.Neighbors:EnumerateItems()) do
                  queue:Enqueue(locationToPoint:get(neighbor))
                end
              end
              continue = true
            until 1
            if not continue then
              break
            end
          end

          otherCenters:Remove(center)
          centerToCenters:Add(center, otherCenters)
          continue = true
        until 1
        if not continue then
          break
        end
      end

      return centerToCenters
    end
    GetLocationToFlutePoint = function (context)
      local fluteTree = GetFluteTree(context)

      -- VisualizeFLUTE(context, context.CenterToTerminals.SelectMany(p => p.Value).Select(l => (IPoint)new Point(l.Terminal.X, l.Terminal.Y)), fluteTree);

      -- Map the FLUTE tree into a more useful object graph.
      local locationToPoint = context:GetLocationDictionary(class.FlutePoint)

      local function GetOrAddPoint(locationToPoint, branch) 
        local location = KnapcodeOilField.Location(branch.X, branch.Y)
        local default, point = locationToPoint:TryGetValue(location)
        if not default then
          point = class.FlutePoint(context, location)
          locationToPoint:Add(location, point)
        end

        return point
      end

      -- Explore the branches.
      for _, branch in System.each(fluteTree.Branch) do
        local current = branch:__clone__()
        while true do
          local next = fluteTree.Branch:get(current.N)

          local currentPoint = GetOrAddPoint(locationToPoint, current:__clone__())
          local nextPoint = GetOrAddPoint(locationToPoint, next:__clone__())

          currentPoint.Neighbors:Add(nextPoint.Location)
          nextPoint.Neighbors:Add(currentPoint.Location)

          if current.N == next.N then
            break
          end

          current = next:__clone__()
        end
      end

      -- Remove self from neighbors
      for _, point in System.each(locationToPoint:getValues()) do
        point.Neighbors:Remove(point.Location)
      end

      -- Add in pumpjack information
      for _, default in System.each(context.CenterToTerminals:EnumeratePairs()) do
        local center, terminals = default:Deconstruct()
        for i = 0, terminals:getCount() - 1 do
          local terminal = terminals:get(i)
          local point = locationToPoint:get(terminal.Terminal)
          point.Terminals:Add(terminal)
          point.Centers:Add(center)
        end
      end

      return locationToPoint
    end
    GetFluteTree = function (context)
      --[[
        var centerPoints = context
            .CenterToTerminals
            .Keys
            .Select(l => new System.Drawing.Point(l.X, l.Y))
            .ToList();
        ]]

      local terminalPoints = ListPoint()
      for _, terminals in System.each(context.CenterToTerminals:getValues()) do
        for i = 0, terminals:getCount() - 1 do
          local terminal = terminals:get(i)
          terminalPoints:Add(KnapcodeFluteSharp.Point(terminal.Terminal.X, terminal.Terminal.Y))
        end
      end

      --[[
        var pumpjackPoints = context
            .Grid
            .LocationToEntity
            .Where(p => p.Value is PumpjackSide || p.Value is PumpjackCenter)
            .Select(p => p.Key)
            .Select(l => new System.Drawing.Point(l.X, l.Y))
            .ToList();
        ]]

      KnapcodeOilField.InitializeFLUTE.Execute(6)

      return KnapcodeOilField.InitializeFLUTE.FLUTE:Execute(terminalPoints)
    end
    class = {
      Execute = Execute
    }
    return class
  end)
end)
