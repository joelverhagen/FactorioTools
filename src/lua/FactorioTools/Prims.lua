-- Generated by CSharp.lua Compiler
local System = System
local KnapcodeFactorioTools
local KnapcodeOilField
local PriorityQueueTupleInt32
System.import(function (out)
  KnapcodeFactorioTools = Knapcode.FactorioTools
  KnapcodeOilField = Knapcode.FactorioTools.OilField
  PriorityQueueTupleInt32 = System.PriorityQueue(System.Tuple, System.Int32)
end)
System.namespace("Knapcode.FactorioTools.OilField", function (namespace)
  namespace.class("Prims", function (namespace)
    local GetMinimumSpanningTree
    GetMinimumSpanningTree = function (context, graph, firstNode, digraph)
      local priority = PriorityQueueTupleInt32()
      local mst = context:GetLocationDictionary(KnapcodeOilField.ILocationSet)


      local visited = context:GetLocationSet1()
      visited:Add(firstNode)
      for _, default in System.each(graph:get(firstNode):EnumeratePairs()) do
        local otherNode, cost = default:Deconstruct()
        priority:Enqueue(System.Tuple(firstNode, otherNode), cost)
      end

      while #priority > 0 do
        local continue
        repeat
          local nodeA, nodeB = priority:Dequeue():Deconstruct()
          if not visited:Add(nodeB) then
            continue = true
            break
          end

          local extern, nodes = mst:TryGetValue(nodeA)
          if not extern then
            nodes = context:GetLocationSet4(nodeB, true)
            mst:Add(nodeA, nodes)
          else
            nodes:Add(nodeB)
          end

          for _, ref in System.each(graph:get(nodeB):EnumeratePairs()) do
            local neighbor, cost = ref:Deconstruct()
            if not visited:Contains(neighbor) then
              priority:Enqueue(System.Tuple(nodeB, neighbor), cost)
            end
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      if not digraph then
        -- Make the MST bidirectional (a graph, not a digraph).
        local keys = KnapcodeFactorioTools.CollectionExtensions.ToTableArray(mst:getKeys(), KnapcodeOilField.Location)
        for i = 0, keys:getCount() - 1 do
          local center = keys:get(i)
          for _, neighbor in System.each(mst:get(center):EnumerateItems()) do
            local extern, otherNeighbors = mst:TryGetValue(neighbor)
            if not extern then
              otherNeighbors = context:GetLocationSet4(center, true)
              mst:Add(neighbor, otherNeighbors)
            else
              otherNeighbors:Add(center)
            end
          end
        end
      end

      return mst
    end
    return {
      GetMinimumSpanningTree = GetMinimumSpanningTree
    }
  end)
end)
