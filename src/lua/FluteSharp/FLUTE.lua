-- Generated by CSharp.lua Compiler
local System = System
local ArrayInt32 = System.Array(System.Int32)
local ArraySingle = System.Array(System.Single)
local ReadOnlySpanInt32 = System.ReadOnlySpan(System.Int32)
local KnapcodeFluteSharp
local ArrayBranch
local ListValueTuple
System.import(function (out)
  KnapcodeFluteSharp = Knapcode.FluteSharp
  ArrayBranch = System.Array(KnapcodeFluteSharp.Branch)
  ListValueTuple = System.List(System.ValueTuple)
end)
System.namespace("Knapcode.FluteSharp", function (namespace)
  namespace.class("FLUTE", function (namespace)
    local Execute, Execute1, GetManhattanDistance, flutes, flutes_LD, flutes_MD, BreakPt, BreakInX, 
    dmergetree, hmergetree, vmergetree, __ctor__
    __ctor__ = function (this, lut)
      this._lut = lut
    end
    Execute = function (this, points)
      return Execute1(this, points, 3)
    end
    Execute1 = function (this, points, accuracy)
      if points:getCount() == 1 then
        local default = KnapcodeFluteSharp.Tree()
        default.Deg = 1
        default.Length = 0
        local extern = KnapcodeFluteSharp.Branch()
        extern.X = points:get(0).X
        extern.Y = points:get(0).Y
        extern.N = 0
        default.Branch = ArrayBranch { extern }
        return default
      elseif points:getCount() == 2 then
        local default = KnapcodeFluteSharp.Tree()
        default.Deg = 2
        default.Length = GetManhattanDistance(points:get(0), points:get(1))
        local extern = KnapcodeFluteSharp.Branch()
        extern.X = points:get(0).X
        extern.Y = points:get(0).Y
        extern.N = 1
        local ref = KnapcodeFluteSharp.Branch()
        ref.X = points:get(1).X
        ref.Y = points:get(1).Y
        ref.N = 1
        default.Branch = ArrayBranch { extern, ref }
        return default
      end

      local pointsByX = ListValueTuple(points:getCount())
      for i = 0, points:getCount() - 1 do
        pointsByX:Add(System.ValueTuple(points:get(i), i))
      end
      pointsByX:Sort(function (a, b)
        local xComparison = System.Int32.CompareTo(a[1].X, b[1].X)
        if xComparison ~= 0 then
          return xComparison
        end

        return System.Int32.CompareTo(a[2], b[2])
      end)

      local pointsByY = ListValueTuple(#pointsByX)
      for i = 0, #pointsByX - 1 do
        pointsByY:Add(System.ValueTuple(pointsByX:get(i)[1], i))
      end
      pointsByY:Sort(function (a, b)
        local yComparison = System.Int32.CompareTo(a[1].Y, b[1].Y)
        if yComparison ~= 0 then
          return yComparison
        end

        return System.Int32.CompareTo(a[2], b[2])
      end)

      local xs = ArrayInt32(points:getCount())
      local ys = ArrayInt32(points:getCount())
      local s = ArrayInt32(points:getCount())

      for i = 0, points:getCount() - 1 do
        xs:set(i, pointsByX:get(i)[1].X)
        ys:set(i, pointsByY:get(i)[1].Y)
        s:set(i, pointsByY:get(i)[2])
      end

      return flutes(this, points:getCount(), ReadOnlySpanInt32.ctorArray(xs), ReadOnlySpanInt32.ctorArray(ys), ReadOnlySpanInt32.ctorArray(s), accuracy)
    end
    GetManhattanDistance = function (a, b)
      return math.Abs(a.X - b.X) + math.Abs(a.Y - b.Y)
    end
    flutes = function (this, d, xs, ys, s, acc)
      if d <= this._lut.D then
        return flutes_LD(this, d, xs, ys, s, acc)
      else
        return flutes_MD(this, d, xs, ys, s, acc)
      end
    end
    flutes_LD = function (this, d, xs, ys, s, acc)
      local k, pi, i, j
      local rlistarr
      local rlisti = 0
      local bestrlist
      local dd = ArrayInt32(2 * this._lut.D - 2)
      -- 0..D-2 for v, D-1..2*D-3 for h
      local minl, sum
      local l = ArrayInt32(this._lut.MPOWV + 1)
      local hflip
      local t = KnapcodeFluteSharp.Tree()

      t.Deg = d
      t.Branch = ArrayBranch(2 * d - 2)
      if d == 2 then
        minl = xs:get(1) - xs:get(0) + ys:get(1) - ys:get(0)
        t.Branch:get(0).X = xs:get(s:get(0))
        t.Branch:get(0).Y = ys:get(0)
        t.Branch:get(0).N = 1
        t.Branch:get(1).X = xs:get(s:get(1))
        t.Branch:get(1).Y = ys:get(1)
        t.Branch:get(1).N = 1
      elseif d == 3 then
        minl = xs:get(2) - xs:get(0) + ys:get(2) - ys:get(0)
        t.Branch:get(0).X = xs:get(s:get(0))
        t.Branch:get(0).Y = ys:get(0)
        t.Branch:get(0).N = 3
        t.Branch:get(1).X = xs:get(s:get(1))
        t.Branch:get(1).Y = ys:get(1)
        t.Branch:get(1).N = 3
        t.Branch:get(2).X = xs:get(s:get(2))
        t.Branch:get(2).Y = ys:get(2)
        t.Branch:get(2).N = 3
        t.Branch:get(3).X = xs:get(1)
        t.Branch:get(3).Y = ys:get(1)
        t.Branch:get(3).N = 3
      else
        k = 0
        if s:get(0) < s:get(2) then
          k = k + 1
        end
        if s:get(1) < s:get(2) then
          k = k + 1
        end

        do
          i = 3
          while i <= d - 1 do
            -- p0=0 always, skip i=1 for symmetry
            pi = s:get(i)
            do
              j = d - 1
              while j > i do
                if s:get(j) < s:get(i) then
                  pi = pi - 1
                end
                j = j - 1
              end
            end
            k = pi + (i + 1) * k
            i = i + 1
          end
        end

        if k < KnapcodeFluteSharp.LookUpTable.numgrp:get(d) then
          -- no horizontal flip
          hflip = 0
          do
            i = 1
            while i <= d - 3 do
              dd:set(i, ys:get(i + 1) - ys:get(i))
              dd:set(d - 1 + i, xs:get(i + 1) - xs:get(i))
              i = i + 1
            end
          end
        else
          hflip = 1
          k = 2 * KnapcodeFluteSharp.LookUpTable.numgrp:get(d) - 1 - k
          do
            i = 1
            while i <= d - 3 do
              dd:set(i, ys:get(i + 1) - ys:get(i))
              dd:set(d - 1 + i, xs:get(d - 1 - i) - xs:get(d - 2 - i))
              i = i + 1
            end
          end
        end

        l:set(0, xs:get(d - 1) - xs:get(0) + ys:get(d - 1) - ys:get(0)) minl = l:get(0)
        rlistarr = this._lut.LUT:get(d, k)
        do
          i = 0
          while rlistarr:get(0).seg:get(i) > 0 do
            minl = minl + dd:get(rlistarr:get(0).seg:get(i))
            i = i + 1
          end
        end
        bestrlist = rlistarr:get(0)
        l:set(1, minl)
        j = 2
        while j <= this._lut.numsoln:get(d, k) do
          rlisti = rlisti + 1
          sum = l:get(rlistarr:get(rlisti).parent)
          do
            i = 0
            while rlistarr:get(rlisti).seg:get(i) > 0 do
              sum = sum + dd:get(rlistarr:get(rlisti).seg:get(i))
              i = i + 1
            end
          end
          do
            i = 10
            while rlistarr:get(rlisti).seg:get(i) > 0 do
              sum = sum - dd:get(rlistarr:get(rlisti).seg:get(i))
              i = i - 1
            end
          end
          if sum < minl then
            minl = sum
            bestrlist = rlistarr:get(rlisti)
          end
          local default = j
          j = default + 1
          l:set(default, sum)
        end

        t.Branch:get(0).X = xs:get(s:get(0))
        t.Branch:get(0).Y = ys:get(0)
        t.Branch:get(1).X = xs:get(s:get(1))
        t.Branch:get(1).Y = ys:get(1)
        do
          i = 2
          while i < d - 2 do
            t.Branch:get(i).X = xs:get(s:get(i))
            t.Branch:get(i).Y = ys:get(i)
            t.Branch:get(i).N = bestrlist.neighbor:get(i)
            i = i + 1
          end
        end
        t.Branch:get(d - 2).X = xs:get(s:get(d - 2))
        t.Branch:get(d - 2).Y = ys:get(d - 2)
        t.Branch:get(d - 1).X = xs:get(s:get(d - 1))
        t.Branch:get(d - 1).Y = ys:get(d - 1)
        if hflip > 0 then
          if s:get(1) < s:get(0) then
            t.Branch:get(0).N = bestrlist.neighbor:get(1)
            t.Branch:get(1).N = bestrlist.neighbor:get(0)
          else
            t.Branch:get(0).N = bestrlist.neighbor:get(0)
            t.Branch:get(1).N = bestrlist.neighbor:get(1)
          end
          if s:get(d - 1) < s:get(d - 2) then
            t.Branch:get(d - 2).N = bestrlist.neighbor:get(d - 1)
            t.Branch:get(d - 1).N = bestrlist.neighbor:get(d - 2)
          else
            t.Branch:get(d - 2).N = bestrlist.neighbor:get(d - 2)
            t.Branch:get(d - 1).N = bestrlist.neighbor:get(d - 1)
          end
          do
            i = d
            while i < 2 * d - 2 do
              t.Branch:get(i).X = xs:get(d - 1 - System.mod(bestrlist.rowcol:get(i - d), 16))
              t.Branch:get(i).Y = ys:get(System.div(bestrlist.rowcol:get(i - d), 16))
              t.Branch:get(i).N = bestrlist.neighbor:get(i)
              i = i + 1
            end
          end
        else
          -- !hflip
          if s:get(0) < s:get(1) then
            t.Branch:get(0).N = bestrlist.neighbor:get(1)
            t.Branch:get(1).N = bestrlist.neighbor:get(0)
          else
            t.Branch:get(0).N = bestrlist.neighbor:get(0)
            t.Branch:get(1).N = bestrlist.neighbor:get(1)
          end
          if s:get(d - 2) < s:get(d - 1) then
            t.Branch:get(d - 2).N = bestrlist.neighbor:get(d - 1)
            t.Branch:get(d - 1).N = bestrlist.neighbor:get(d - 2)
          else
            t.Branch:get(d - 2).N = bestrlist.neighbor:get(d - 2)
            t.Branch:get(d - 1).N = bestrlist.neighbor:get(d - 1)
          end
          do
            i = d
            while i < 2 * d - 2 do
              t.Branch:get(i).X = xs:get(System.mod(bestrlist.rowcol:get(i - d), 16))
              t.Branch:get(i).Y = ys:get(System.div(bestrlist.rowcol:get(i - d), 16))
              t.Branch:get(i).N = bestrlist.neighbor:get(i)
              i = i + 1
            end
          end
        end
      end
      t.Length = minl

      return t
    end
    flutes_MD = function (this, d, xs, ys, s, acc)
      local x1 = ArrayInt32(d) local x2 = ArrayInt32(d) local y1 = ArrayInt32(d) local y2 = ArrayInt32(d)
      local si = ArrayInt32(d) local s1 = ArrayInt32(d) local s2 = ArrayInt32(d)
      local score = ArraySingle(2 * d) local penalty = ArraySingle(d)
      local pnlty, dx, dy
      local ll, minl, coord1, coord2
      local i local r local p local maxbp local bestbp = 0 local bp local nbp local ub local lb local n1 local n2 local nn1 = 0 local nn2 = 0 local newacc
      local t, t1, t2, bestt1, bestt2
      local ms, mins, maxs, minsi, maxsi
      local distx = ArrayInt32(d) local disty = ArrayInt32(d)
      local xydiff

      if s:get(0) < s:get(d - 1) then
        ms = math.Max(s:get(0), s:get(1))
        do
          i = 2
          while i <= ms do
            ms = math.Max(ms, s:get(i))
            i = i + 1
          end
        end
        if ms <= d - 3 then
          do
            i = 0
            while i <= ms do
              x1:set(i, xs:get(i))
              y1:set(i, ys:get(i))
              s1:set(i, s:get(i))
              i = i + 1
            end
          end
          x1:set(ms + 1, xs:get(ms))
          y1:set(ms + 1, ys:get(ms))
          s1:set(ms + 1, ms + 1)

          s2:set(0, 0)
          do
            i = 1
            while i <= d - 1 - ms do
              s2:set(i, s:get(i + ms) - ms)
              i = i + 1
            end
          end

          t1 = flutes(this, ms + 2, ReadOnlySpanInt32.ctorArray(x1), ReadOnlySpanInt32.ctorArray(y1), ReadOnlySpanInt32.ctorArray(s1), acc)
          t2 = flutes(this, d - ms, xs:Slice(ms), ys:Slice(ms), ReadOnlySpanInt32.ctorArray(s2), acc)
          t = dmergetree(t1, t2)

          return t
        end
      else
        -- (s[0] > s[d-1])
        ms = math.Min(s:get(0), s:get(1))
        do
          i = 2
          while i <= d - 1 - ms do
            ms = math.Min(ms, s:get(i))
            i = i + 1
          end
        end
        if ms >= 2 then
          x1:set(0, xs:get(ms))
          y1:set(0, ys:get(0))
          s1:set(0, s:get(0) - ms + 1)
          do
            i = 1
            while i <= d - 1 - ms do
              x1:set(i, xs:get(i + ms - 1))
              y1:set(i, ys:get(i))
              s1:set(i, s:get(i) - ms + 1)
              i = i + 1
            end
          end
          x1:set(d - ms, xs:get(d - 1))
          y1:set(d - ms, ys:get(d - 1 - ms))
          s1:set(d - ms, 0)

          s2:set(0, ms)
          do
            i = 1
            while i <= ms do
              s2:set(i, s:get(i + d - 1 - ms))
              i = i + 1
            end
          end

          t1 = flutes(this, d + 1 - ms, ReadOnlySpanInt32.ctorArray(x1), ReadOnlySpanInt32.ctorArray(y1), ReadOnlySpanInt32.ctorArray(s1), acc)
          t2 = flutes(this, ms + 1, xs, ys:Slice(d - 1 - ms), ReadOnlySpanInt32.ctorArray(s2), acc)
          t = dmergetree(t1, t2)

          return t
        end
      end

      -- Find inverse si[] of s[]
      do
        r = 0
        while r < d do
          si:set(s:get(r), r)
          r = r + 1
        end
      end

      -- Determine breaking directions and positions dp[]
      lb = System.div((d - 2 * acc + 2), 4)
      if lb < 2 then
        lb = 2
      end
      ub = d - 1 - lb

      -- Compute scores    
      -- 2.0*BB
      local CC = 7.4 / ((d + 10.0) * (d - 3.0))
      local DD = 4.8 / (d - 1)

      -- Compute penalty[]    
      dx = CC * (xs:get(d - 2) - xs:get(1))
      dy = CC * (ys:get(d - 2) - ys:get(1))
      do
        r = System.div(d, 2)
        pnlty = 0
        while r >= 2 do
          penalty:set(r, pnlty)
          penalty:set(d - 1 - r, pnlty)
          r = r - 1
          pnlty = pnlty + dx
        end
      end

      penalty:set(1, pnlty)
      penalty:set(d - 2, pnlty)
      penalty:set(0, pnlty)
      penalty:set(d - 1, pnlty)

      do
        r = System.div(d, 2) - 1
        pnlty = dy
        while r >= 2 do
          penalty:set(s:get(r), penalty:get(s:get(r)) + pnlty)
          penalty:set(s:get(d - 1 - r), penalty:get(s:get(d - 1 - r)) + pnlty)
          r = r - 1
          pnlty = pnlty + dy
        end
      end

      penalty:set(s:get(1), penalty:get(s:get(1)) + pnlty)
      penalty:set(s:get(d - 2), penalty:get(s:get(d - 2)) + pnlty)
      penalty:set(s:get(0), penalty:get(s:get(0)) + pnlty)
      penalty:set(s:get(d - 1), penalty:get(s:get(d - 1)) + pnlty)
      --#define CC 0.16
      --#define v(r) ((r==0||r==1||r==d-2||r==d-1) ? d-3 : abs(d-1-r-r))
      --    for (r=0; r<d; r++)
      --        penalty[r] = v(r)*dx + v(si[r])*dy;

      -- Compute distx[], disty[]
      xydiff = (xs:get(d - 1) - xs:get(0)) - (ys:get(d - 1) - ys:get(0))
      if s:get(0) < s:get(1) then
        mins = s:get(0)
        maxs = s:get(1)
      else
        mins = s:get(1)
        maxs = s:get(0)
      end
      if si:get(0) < si:get(1) then
        minsi = si:get(0)
        maxsi = si:get(1)
      else
        minsi = si:get(1)
        maxsi = si:get(0)
      end
      do
        r = 2
        while r <= ub do
          if s:get(r) < mins then
            mins = s:get(r)
          elseif s:get(r) > maxs then
            maxs = s:get(r)
          end
          distx:set(r, xs:get(maxs) - xs:get(mins))
          if si:get(r) < minsi then
            minsi = si:get(r)
          elseif si:get(r) > maxsi then
            maxsi = si:get(r)
          end
          disty:set(r, ys:get(maxsi) - ys:get(minsi) + xydiff)
          r = r + 1
        end
      end

      if s:get(d - 2) < s:get(d - 1) then
        mins = s:get(d - 2)
        maxs = s:get(d - 1)
      else
        mins = s:get(d - 1)
        maxs = s:get(d - 2)
      end

      if si:get(d - 2) < si:get(d - 1) then
        minsi = si:get(d - 2)
        maxsi = si:get(d - 1)
      else
        minsi = si:get(d - 1)
        maxsi = si:get(d - 2)
      end

      do
        r = d - 3
        while r >= lb do
          if s:get(r) < mins then
            mins = s:get(r)
          elseif s:get(r) > maxs then
            maxs = s:get(r)
          end
          distx:set(r, distx:get(r) + (xs:get(maxs) - xs:get(mins)))
          if si:get(r) < minsi then
            minsi = si:get(r)
          elseif si:get(r) > maxsi then
            maxsi = si:get(r)
          end
          disty:set(r, disty:get(r) + (ys:get(maxsi) - ys:get(minsi)))
          r = r - 1
        end
      end

      nbp = 0
      do
        r = lb
        while r <= ub do
          if si:get(r) <= 1 then
            score:set(nbp, (xs:get(r + 1) - xs:get(r - 1)) - penalty:get(r) - 0.600000024 --[[AA]] * (ys:get(2) - ys:get(1)) - DD * disty:get(r))
          elseif si:get(r) >= d - 2 then
            score:set(nbp, (xs:get(r + 1) - xs:get(r - 1)) - penalty:get(r) - 0.600000024 --[[AA]] * (ys:get(d - 2) - ys:get(d - 3)) - DD * disty:get(r))
          else
            score:set(nbp, (xs:get(r + 1) - xs:get(r - 1)) - penalty:get(r) - 0.300000012 --[[BB]] * (ys:get(si:get(r) + 1) - ys:get(si:get(r) - 1)) - DD * disty:get(r))
          end
          nbp = nbp + 1

          if s:get(r) <= 1 then
            score:set(nbp, (ys:get(r + 1) - ys:get(r - 1)) - penalty:get(s:get(r)) - 0.600000024 --[[AA]] * (xs:get(2) - xs:get(1)) - DD * distx:get(r))
          elseif s:get(r) >= d - 2 then
            score:set(nbp, (ys:get(r + 1) - ys:get(r - 1)) - penalty:get(s:get(r)) - 0.600000024 --[[AA]] * (xs:get(d - 2) - xs:get(d - 3)) - DD * distx:get(r))
          else
            score:set(nbp, (ys:get(r + 1) - ys:get(r - 1)) - penalty:get(s:get(r)) - 0.300000012 --[[BB]] * (xs:get(s:get(r) + 1) - xs:get(s:get(r) - 1)) - DD * distx:get(r))
          end
          nbp = nbp + 1
          r = r + 1
        end
      end

      if acc <= 3 then
        newacc = 1
      else
        newacc = System.div(acc, 2)
        if acc >= nbp then
          acc = nbp - 1
        end
      end

      minl = 2147483647 --[[Int32.MaxValue]]
      bestt1 = KnapcodeFluteSharp.Tree()
      bestt2 = KnapcodeFluteSharp.Tree()
      bestt2.Branch = System.Array.Empty(KnapcodeFluteSharp.Branch) bestt1.Branch = bestt2.Branch
      do
        i = 0
        while i < acc do
          maxbp = 0
          do
            bp = 1
            while bp < nbp do
              if score:get(maxbp) < score:get(bp) then
                maxbp = bp
              end
              bp = bp + 1
            end
          end
          score:set(maxbp, - 9e9)

          p = BreakPt(maxbp, lb)
          -- Breaking in p
          if BreakInX(maxbp) then
            -- break in x
            n2 = 0 n1 = n2
            do
              r = 0
              while r < d do
                if s:get(r) < p then
                  s1:set(n1, s:get(r))
                  y1:set(n1, ys:get(r))
                  n1 = n1 + 1
                elseif s:get(r) > p then
                  s2:set(n2, s:get(r) - p)
                  y2:set(n2, ys:get(r))
                  n2 = n2 + 1
                else
                  -- if (s[r] == p)  i.e.,  r = si[p]
                  s1:set(n1, p)
                  s2:set(n2, 0)
                  y2:set(n2, ys:get(r)) y1:set(n1, y2:get(n2))
                  nn1 = n1
                  nn2 = n2
                  n1 = n1 + 1
                  n2 = n2 + 1
                end
                r = r + 1
              end
            end

            t1 = flutes(this, p + 1, xs, ReadOnlySpanInt32.ctorArray(y1), ReadOnlySpanInt32.ctorArray(s1), newacc)
            t2 = flutes(this, d - p, xs:Slice(p), ReadOnlySpanInt32.ctorArray(y2), ReadOnlySpanInt32.ctorArray(s2), newacc)
            ll = t1.Length + t2.Length
            coord1 = t1.Branch:get(t1.Branch:get(nn1).N).Y
            coord2 = t2.Branch:get(t2.Branch:get(nn2).N).Y
            if t2.Branch:get(nn2).Y > math.Max(coord1, coord2) then
              ll = ll - ((t2.Branch:get(nn2).Y - math.Max(coord1, coord2)))
            elseif t2.Branch:get(nn2).Y < math.Min(coord1, coord2) then
              ll = ll - ((math.Min(coord1, coord2) - t2.Branch:get(nn2).Y))
            end
          else
            -- if (!BreakInX(maxbp))
            n2 = 0 n1 = n2
            do
              r = 0
              while r < d do
                if si:get(r) < p then
                  s1:set(si:get(r), n1)
                  x1:set(n1, xs:get(r))
                  n1 = n1 + 1
                elseif si:get(r) > p then
                  s2:set(si:get(r) - p, n2)
                  x2:set(n2, xs:get(r))
                  n2 = n2 + 1
                else
                  -- if (si[r] == p)  i.e.,  r = s[p]
                  s1:set(p, n1)
                  s2:set(0, n2)
                  x2:set(n2, xs:get(r)) x1:set(n1, x2:get(n2))
                  n1 = n1 + 1
                  n2 = n2 + 1
                end
                r = r + 1
              end
            end

            t1 = flutes(this, p + 1, ReadOnlySpanInt32.ctorArray(x1), ys, ReadOnlySpanInt32.ctorArray(s1), newacc)
            t2 = flutes(this, d - p, ReadOnlySpanInt32.ctorArray(x2), ys:Slice(p), ReadOnlySpanInt32.ctorArray(s2), newacc)
            ll = t1.Length + t2.Length
            coord1 = t1.Branch:get(t1.Branch:get(p).N).X
            coord2 = t2.Branch:get(t2.Branch:get(0).N).X
            if t2.Branch:get(0).X > math.Max(coord1, coord2) then
              ll = ll - ((t2.Branch:get(0).X - math.Max(coord1, coord2)))
            elseif t2.Branch:get(0).X < math.Min(coord1, coord2) then
              ll = ll - ((math.Min(coord1, coord2) - t2.Branch:get(0).X))
            end
          end
          if minl > ll then
            minl = ll
            bestt1 = t1
            bestt2 = t2
            bestbp = maxbp
          end
          i = i + 1
        end
      end

      if BreakInX(bestbp) then
        t = hmergetree(bestt1, bestt2, s)
      else
        t = vmergetree(bestt1, bestt2)
      end


      return t
    end
    BreakPt = function (bp, lb)
      return (System.div(bp, 2) + lb)
    end
    BreakInX = function (bp)
      return (System.mod(bp, 2) == 0)
    end
    dmergetree = function (t1, t2)
      local i, d, prev, curr, next, offset1, offset2
      local t = KnapcodeFluteSharp.Tree()

      d = t1.Deg + t2.Deg - 2 t.Deg = d
      t.Length = t1.Length + t2.Length
      t.Branch = ArrayBranch(2 * d - 2)
      offset1 = t2.Deg - 2
      offset2 = 2 * t1.Deg - 4

      do
        i = 0
        while i <= t1.Deg - 2 do
          t.Branch:get(i).X = t1.Branch:get(i).X
          t.Branch:get(i).Y = t1.Branch:get(i).Y
          t.Branch:get(i).N = t1.Branch:get(i).N + offset1
          i = i + 1
        end
      end
      do
        i = t1.Deg - 1
        while i <= d - 1 do
          t.Branch:get(i).X = t2.Branch:get(i - t1.Deg + 2).X
          t.Branch:get(i).Y = t2.Branch:get(i - t1.Deg + 2).Y
          t.Branch:get(i).N = t2.Branch:get(i - t1.Deg + 2).N + offset2
          i = i + 1
        end
      end
      do
        i = d
        while i <= d + t1.Deg - 3 do
          t.Branch:get(i).X = t1.Branch:get(i - offset1).X
          t.Branch:get(i).Y = t1.Branch:get(i - offset1).Y
          t.Branch:get(i).N = t1.Branch:get(i - offset1).N + offset1
          i = i + 1
        end
      end
      do
        i = d + t1.Deg - 2
        while i <= 2 * d - 3 do
          t.Branch:get(i).X = t2.Branch:get(i - offset2).X
          t.Branch:get(i).Y = t2.Branch:get(i - offset2).Y
          t.Branch:get(i).N = t2.Branch:get(i - offset2).N + offset2
          i = i + 1
        end
      end

      prev = t2.Branch:get(0).N + offset2
      curr = t1.Branch:get(t1.Deg - 1).N + offset1
      next = t.Branch:get(curr).N
      while curr ~= next do
        t.Branch:get(curr).N = prev
        prev = curr
        curr = next
        next = t.Branch:get(curr).N
      end
      t.Branch:get(curr).N = prev

      return t
    end
    hmergetree = function (t1, t2, s)
      local i, prev, curr, next, extra, offset1, offset2
      local p local ii = 0 local n1 local n2 local nn1 = 0 local nn2 = 0
      local coord1, coord2
      local t = KnapcodeFluteSharp.Tree()

      t.Deg = t1.Deg + t2.Deg - 1
      t.Length = t1.Length + t2.Length
      t.Branch = ArrayBranch(2 * t.Deg - 2)
      offset1 = t2.Deg - 1
      offset2 = 2 * t1.Deg - 3

      p = t1.Deg - 1
      n2 = 0 n1 = n2
      do
        i = 0
        while i < t.Deg do
          if s:get(i) < p then
            t.Branch:get(i).X = t1.Branch:get(n1).X
            t.Branch:get(i).Y = t1.Branch:get(n1).Y
            t.Branch:get(i).N = t1.Branch:get(n1).N + offset1
            n1 = n1 + 1
          elseif s:get(i) > p then
            t.Branch:get(i).X = t2.Branch:get(n2).X
            t.Branch:get(i).Y = t2.Branch:get(n2).Y
            t.Branch:get(i).N = t2.Branch:get(n2).N + offset2
            n2 = n2 + 1
          else
            t.Branch:get(i).X = t2.Branch:get(n2).X
            t.Branch:get(i).Y = t2.Branch:get(n2).Y
            t.Branch:get(i).N = t2.Branch:get(n2).N + offset2
            nn1 = n1
            nn2 = n2
            ii = i
            n1 = n1 + 1
            n2 = n2 + 1
          end
          i = i + 1
        end
      end
      do
        i = t.Deg
        while i <= t.Deg + t1.Deg - 3 do
          t.Branch:get(i).X = t1.Branch:get(i - offset1).X
          t.Branch:get(i).Y = t1.Branch:get(i - offset1).Y
          t.Branch:get(i).N = t1.Branch:get(i - offset1).N + offset1
          i = i + 1
        end
      end
      do
        i = t.Deg + t1.Deg - 2
        while i <= 2 * t.Deg - 4 do
          t.Branch:get(i).X = t2.Branch:get(i - offset2).X
          t.Branch:get(i).Y = t2.Branch:get(i - offset2).Y
          t.Branch:get(i).N = t2.Branch:get(i - offset2).N + offset2
          i = i + 1
        end
      end
      extra = 2 * t.Deg - 3
      coord1 = t1.Branch:get(t1.Branch:get(nn1).N).Y
      coord2 = t2.Branch:get(t2.Branch:get(nn2).N).Y
      if t2.Branch:get(nn2).Y > math.Max(coord1, coord2) then
        t.Branch:get(extra).Y = math.Max(coord1, coord2)
        t.Length = t.Length - ((t2.Branch:get(nn2).Y - t.Branch:get(extra).Y))
      elseif t2.Branch:get(nn2).Y < math.Min(coord1, coord2) then
        t.Branch:get(extra).Y = math.Min(coord1, coord2)
        t.Length = t.Length - ((t.Branch:get(extra).Y - t2.Branch:get(nn2).Y))
      else
        t.Branch:get(extra).Y = t2.Branch:get(nn2).Y
      end
      t.Branch:get(extra).X = t2.Branch:get(nn2).X
      t.Branch:get(extra).N = t.Branch:get(ii).N
      t.Branch:get(ii).N = extra

      prev = extra
      curr = t1.Branch:get(nn1).N + offset1
      next = t.Branch:get(curr).N
      while curr ~= next do
        t.Branch:get(curr).N = prev
        prev = curr
        curr = next
        next = t.Branch:get(curr).N
      end
      t.Branch:get(curr).N = prev

      return t
    end
    vmergetree = function (t1, t2)
      local i, prev, curr, next, extra, offset1, offset2
      local coord1, coord2
      local t = KnapcodeFluteSharp.Tree()

      t.Deg = t1.Deg + t2.Deg - 1
      t.Length = t1.Length + t2.Length
      t.Branch = ArrayBranch(2 * t.Deg - 2)
      offset1 = t2.Deg - 1
      offset2 = 2 * t1.Deg - 3

      do
        i = 0
        while i <= t1.Deg - 2 do
          t.Branch:get(i).X = t1.Branch:get(i).X
          t.Branch:get(i).Y = t1.Branch:get(i).Y
          t.Branch:get(i).N = t1.Branch:get(i).N + offset1
          i = i + 1
        end
      end
      do
        i = t1.Deg - 1
        while i <= t.Deg - 1 do
          t.Branch:get(i).X = t2.Branch:get(i - t1.Deg + 1).X
          t.Branch:get(i).Y = t2.Branch:get(i - t1.Deg + 1).Y
          t.Branch:get(i).N = t2.Branch:get(i - t1.Deg + 1).N + offset2
          i = i + 1
        end
      end
      do
        i = t.Deg
        while i <= t.Deg + t1.Deg - 3 do
          t.Branch:get(i).X = t1.Branch:get(i - offset1).X
          t.Branch:get(i).Y = t1.Branch:get(i - offset1).Y
          t.Branch:get(i).N = t1.Branch:get(i - offset1).N + offset1
          i = i + 1
        end
      end
      do
        i = t.Deg + t1.Deg - 2
        while i <= 2 * t.Deg - 4 do
          t.Branch:get(i).X = t2.Branch:get(i - offset2).X
          t.Branch:get(i).Y = t2.Branch:get(i - offset2).Y
          t.Branch:get(i).N = t2.Branch:get(i - offset2).N + offset2
          i = i + 1
        end
      end
      extra = 2 * t.Deg - 3
      coord1 = t1.Branch:get(t1.Branch:get(t1.Deg - 1).N).X
      coord2 = t2.Branch:get(t2.Branch:get(0).N).X
      if t2.Branch:get(0).X > math.Max(coord1, coord2) then
        t.Branch:get(extra).X = math.Max(coord1, coord2)
        t.Length = t.Length - ((t2.Branch:get(0).X - t.Branch:get(extra).X))
      elseif t2.Branch:get(0).X < math.Min(coord1, coord2) then
        t.Branch:get(extra).X = math.Min(coord1, coord2)
        t.Length = t.Length - ((t.Branch:get(extra).X - t2.Branch:get(0).X))
      else
        t.Branch:get(extra).X = t2.Branch:get(0).X
      end
      t.Branch:get(extra).Y = t2.Branch:get(0).Y
      t.Branch:get(extra).N = t.Branch:get(t1.Deg - 1).N
      t.Branch:get(t1.Deg - 1).N = extra

      prev = extra
      curr = t1.Branch:get(t1.Deg - 1).N + offset1
      next = t.Branch:get(curr).N
      while curr ~= next do
        t.Branch:get(curr).N = prev
        prev = curr
        curr = next
        next = t.Branch:get(curr).N
      end
      t.Branch:get(curr).N = prev

      return t
    end
    return {
      Execute = Execute,
      Execute1 = Execute1,
      __ctor__ = __ctor__
    }
  end)
end)
