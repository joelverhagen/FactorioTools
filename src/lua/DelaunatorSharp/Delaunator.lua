-- Generated by CSharp.lua Compiler
local System = System
local ListInt32 = System.List(System.Int32)
local ArrayInt32 = System.Array(System.Int32)
local ArrayDouble = System.Array(System.Double)
local HashSetInt32 = System.HashSet(System.Int32)
local DelaunatorSharp
local ArrayIEdge
local ListIPoint
local ArrayIPoint
System.import(function (out)
  DelaunatorSharp = out.DelaunatorSharp
  ArrayIEdge = System.Array(DelaunatorSharp.IEdge)
  ListIPoint = System.List(DelaunatorSharp.IPoint)
  ArrayIPoint = System.Array(DelaunatorSharp.IPoint)
end)
System.namespace("DelaunatorSharp", function (namespace)
  namespace.class("Delaunator", function (namespace)
    local Legalize, InCircle, AddTriangle, Link, HashKey, PseudoAngle, Quicksort, Swap, 
    Orient, Circumradius, Circumcenter, Dist, GetTriangles, GetEdges, GetVoronoiEdges, GetVoronoiEdgesBasedOnCircumCenter, 
    GetVoronoiEdgesBasedOnCentroids, GetVoronoiCells, GetVoronoiCellsBasedOnCircumcenters, GetVoronoiCellsBasedOnCentroids, GetHullEdges, GetHullPoints, GetTrianglePoints, GetRellaxedPoints, 
    GetEdgesOfTriangle, CreateHull, GetTriangleCircumcenter, GetCentroid, GetCircumcenter, GetCentroid1, ForEachTriangle, ForEachTriangleEdge, 
    ForEachVoronoiEdge, ForEachVoronoiCellBasedOnCentroids, ForEachVoronoiCellBasedOnCircumcenters, ForEachVoronoiCell, EdgesAroundPoint, PointsOfTriangle, TrianglesAdjacentToTriangle, NextHalfedge, 
    PreviousHalfedge, EdgesOfTriangle, TriangleOfEdge, __ctor__
    __ctor__ = function (this, points)
      this.EPSILON = math.Pow(2, - 52)
      this.EDGE_STACK = ArrayInt32(512)
      if #points < 3 then
        System.throw(System.ArgumentOutOfRangeException("Need at least 3 points"))
      end

      this.Points = points
      this.coords = ArrayDouble(#this.Points * 2)

      for i = 0, #this.Points - 1 do
        local p = this.Points:get(i)
        this.coords:set(2 * i, p:getX())
        this.coords:set(2 * i + 1, p:getY())
      end

      local n = #points
      local maxTriangles = 2 * n - 5

      this.Triangles = ArrayInt32(maxTriangles * 3)

      this.Halfedges = ArrayInt32(maxTriangles * 3)
      this.hashSize = System.ToInt32(math.Ceiling(math.Sqrt(n)))

      this.hullPrev = ArrayInt32(n)
      this.hullNext = ArrayInt32(n)
      this.hullTri = ArrayInt32(n)
      this.hullHash = ArrayInt32(this.hashSize)

      local ids = ArrayInt32(n)

      local minX = System.Double.PositiveInfinity
      local minY = System.Double.PositiveInfinity
      local maxX = System.Double.NegativeInfinity
      local maxY = System.Double.NegativeInfinity

      for i = 0, n - 1 do
        local x = this.coords:get(2 * i)
        local y = this.coords:get(2 * i + 1)
        if x < minX then
          minX = x
        end
        if y < minY then
          minY = y
        end
        if x > maxX then
          maxX = x
        end
        if y > maxY then
          maxY = y
        end
        ids:set(i, i)
      end

      local cx = (minX + maxX) / 2
      local cy = (minY + maxY) / 2

      local minDist = System.Double.PositiveInfinity
      local i0 = 0
      local i1 = 0
      local i2 = 0

      -- pick a seed point close to the center
      for i = 0, n - 1 do
        local d = Dist(cx, cy, this.coords:get(2 * i), this.coords:get(2 * i + 1))
        if d < minDist then
          i0 = i
          minDist = d
        end
      end
      local i0x = this.coords:get(2 * i0)
      local i0y = this.coords:get(2 * i0 + 1)

      minDist = System.Double.PositiveInfinity

      -- find the point closest to the seed
      for i = 0, n - 1 do
        local continue
        repeat
          if i == i0 then
            continue = true
            break
          end
          local d = Dist(i0x, i0y, this.coords:get(2 * i), this.coords:get(2 * i + 1))
          if d < minDist and d > 0 then
            i1 = i
            minDist = d
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      local i1x = this.coords:get(2 * i1)
      local i1y = this.coords:get(2 * i1 + 1)

      local minRadius = System.Double.PositiveInfinity

      -- find the third point which forms the smallest circumcircle with the first two
      for i = 0, n - 1 do
        local continue
        repeat
          if i == i0 or i == i1 then
            continue = true
            break
          end
          local r = Circumradius(i0x, i0y, i1x, i1y, this.coords:get(2 * i), this.coords:get(2 * i + 1))
          if r < minRadius then
            i2 = i
            minRadius = r
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end
      local i2x = this.coords:get(2 * i2)
      local i2y = this.coords:get(2 * i2 + 1)

      if minRadius == System.Double.PositiveInfinity then
        System.throw(System.Exception("No Delaunay triangulation exists for this input."))
      end

      if Orient(i0x, i0y, i1x, i1y, i2x, i2y) then
        local i = i1
        local x = i1x
        local y = i1y
        i1 = i2
        i1x = i2x
        i1y = i2y
        i2 = i
        i2x = x
        i2y = y
      end

      local center = Circumcenter(i0x, i0y, i1x, i1y, i2x, i2y)
      this.cx = center:getX()
      this.cy = center:getY()

      local dists = ArrayDouble(n)
      for i = 0, n - 1 do
        dists:set(i, Dist(this.coords:get(2 * i), this.coords:get(2 * i + 1), center:getX(), center:getY()))
      end

      -- sort the points by distance from the seed triangle circumcenter
      Quicksort(ids, dists, 0, n - 1)

      -- set up the seed triangle as the starting hull
      this.hullStart = i0
      this.hullSize = 3

      this.hullPrev:set(i2, i1) this.hullNext:set(i0, this.hullPrev:get(i2))
      this.hullPrev:set(i0, i2) this.hullNext:set(i1, this.hullPrev:get(i0))
      this.hullPrev:set(i1, i0) this.hullNext:set(i2, this.hullPrev:get(i1))

      this.hullTri:set(i0, 0)
      this.hullTri:set(i1, 1)
      this.hullTri:set(i2, 2)

      this.hullHash:set(HashKey(this, i0x, i0y), i0)
      this.hullHash:set(HashKey(this, i1x, i1y), i1)
      this.hullHash:set(HashKey(this, i2x, i2y), i2)

      this.trianglesLen = 0
      AddTriangle(this, i0, i1, i2, - 1, - 1, - 1)

      local xp = 0
      local yp = 0

      for k = 0, #ids - 1 do
        local continue
        repeat
          local i = ids:get(k)
          local x = this.coords:get(2 * i)
          local y = this.coords:get(2 * i + 1)

          -- skip near-duplicate points
          if k > 0 and math.Abs(x - xp) <= this.EPSILON and math.Abs(y - yp) <= this.EPSILON then
            continue = true
            break
          end
          xp = x
          yp = y

          -- skip seed triangle points
          if i == i0 or i == i1 or i == i2 then
            continue = true
            break
          end

          -- find a visible edge on the convex hull using edge hash
          local start = 0
          for j = 0, this.hashSize - 1 do
            local key = HashKey(this, x, y)
            start = this.hullHash:get(System.mod((key + j), this.hashSize))
            if start ~= - 1 and start ~= this.hullNext:get(start) then
              break
            end
          end


          start = this.hullPrev:get(start)
          local e = start
          local q = this.hullNext:get(e)

          while not Orient(x, y, this.coords:get(2 * e), this.coords:get(2 * e + 1), this.coords:get(2 * q), this.coords:get(2 * q + 1)) do
            e = q
            if e == start then
              e = 2147483647 --[[Int32.MaxValue]]
              break
            end

            q = this.hullNext:get(e)
          end

          if e == 2147483647 --[[Int32.MaxValue]] then
            continue = true
            break
          end
          -- likely a near-duplicate point; skip it

          -- add the first triangle from the point
          local t = AddTriangle(this, e, i, this.hullNext:get(e), - 1, - 1, this.hullTri:get(e))

          -- recursively flip triangles from the point until they satisfy the Delaunay condition
          this.hullTri:set(i, Legalize(this, t + 2))
          this.hullTri:set(e, t)
          -- keep track of boundary triangles on the hull
          this.hullSize = this.hullSize + 1

          -- walk forward through the hull, adding more triangles and flipping recursively
          local next = this.hullNext:get(e)
          q = this.hullNext:get(next)

          while Orient(x, y, this.coords:get(2 * next), this.coords:get(2 * next + 1), this.coords:get(2 * q), this.coords:get(2 * q + 1)) do
            t = AddTriangle(this, next, i, q, this.hullTri:get(i), - 1, this.hullTri:get(next))
            this.hullTri:set(i, Legalize(this, t + 2))
            this.hullNext:set(next, next)
            -- mark as removed
            this.hullSize = this.hullSize - 1
            next = q

            q = this.hullNext:get(next)
          end

          -- walk backward from the other side, adding more triangles and flipping
          if e == start then
            q = this.hullPrev:get(e)

            while Orient(x, y, this.coords:get(2 * q), this.coords:get(2 * q + 1), this.coords:get(2 * e), this.coords:get(2 * e + 1)) do
              t = AddTriangle(this, q, i, e, - 1, this.hullTri:get(e), this.hullTri:get(q))
              Legalize(this, t + 2)
              this.hullTri:set(q, t)
              this.hullNext:set(e, e)
              -- mark as removed
              this.hullSize = this.hullSize - 1
              e = q

              q = this.hullPrev:get(e)
            end
          end

          -- update the hull indices
          this.hullPrev:set(i, e) this.hullStart = this.hullPrev:get(i)
          this.hullPrev:set(next, i) this.hullNext:set(e, this.hullPrev:get(next))
          this.hullNext:set(i, next)

          -- save the two new edges in the hash table
          this.hullHash:set(HashKey(this, x, y), i)
          this.hullHash:set(HashKey(this, this.coords:get(2 * e), this.coords:get(2 * e + 1)), e)
          continue = true
        until 1
        if not continue then
          break
        end
      end

      this.Hull = ArrayInt32(this.hullSize)
      local s = this.hullStart
      for i = 0, this.hullSize - 1 do
        this.Hull:set(i, s)
        s = this.hullNext:get(s)
      end

      this.hullTri = nil this.hullNext = this.hullTri this.hullPrev = this.hullNext
      -- get rid of temporary arrays

      --// trim typed triangle mesh arrays
      local trimmedTriangles = ArrayInt32(this.trianglesLen)
      System.Array.Copy(this.Triangles, trimmedTriangles, this.trianglesLen)
      this.Triangles = trimmedTriangles

      local trimmedHalfedges = ArrayInt32(this.trianglesLen)
      System.Array.Copy(this.Halfedges, trimmedHalfedges, this.trianglesLen)
      this.Halfedges = trimmedHalfedges
    end
    Legalize = function (this, a)
      local i = 0
      local ar

      -- recursion eliminated with a fixed-size stack
      while true do
        local continue
        repeat
          local b = this.Halfedges:get(a)

          --[[ if the pair of triangles doesn't satisfy the Delaunay condition
                 * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
                 * then do the same check/flip recursively for the new pair of triangles
                 *
                 *           pl                    pl
                 *          /||\                  /  \
                 *       al/ || \bl            al/    \a
                 *        /  ||  \              /      \
                 *       /  a||b  \    flip    /___ar___\
                 *     p0\   ||   /p1   =>   p0\---bl---/p1
                 *        \  ||  /              \      /
                 *       ar\ || /br             b\    /br
                 *          \||/                  \  /
                 *           pr                    pr
                 ]]
          local a0 = a - System.mod(a, 3)
          ar = a0 + System.mod((a + 2), 3)

          if b == - 1 then
            -- convex hull edge
            if i == 0 then
              break
            end
            i = i - 1
            a = this.EDGE_STACK:get(i)
            continue = true
            break
          end

          local b0 = b - System.mod(b, 3)
          local al = a0 + System.mod((a + 1), 3)
          local bl = b0 + System.mod((b + 2), 3)

          local p0 = this.Triangles:get(ar)
          local pr = this.Triangles:get(a)
          local pl = this.Triangles:get(al)
          local p1 = this.Triangles:get(bl)

          local illegal = InCircle(this.coords:get(2 * p0), this.coords:get(2 * p0 + 1), this.coords:get(2 * pr), this.coords:get(2 * pr + 1), this.coords:get(2 * pl), this.coords:get(2 * pl + 1), this.coords:get(2 * p1), this.coords:get(2 * p1 + 1))

          if illegal then
            this.Triangles:set(a, p1)
            this.Triangles:set(b, p0)

            local hbl = this.Halfedges:get(bl)

            -- edge swapped on the other side of the hull (rare); fix the halfedge reference
            if hbl == - 1 then
              local e = this.hullStart
              repeat
                if this.hullTri:get(e) == bl then
                  this.hullTri:set(e, a)
                  break
                end
                e = this.hullPrev:get(e)
              until not (e ~= this.hullStart)
            end
            Link(this, a, hbl)
            Link(this, b, this.Halfedges:get(ar))
            Link(this, ar, bl)

            local br = b0 + System.mod((b + 1), 3)

            -- don't worry about hitting the cap: it can only happen on extremely degenerate input
            if i < #this.EDGE_STACK then
              local default = i
              i = default + 1
              this.EDGE_STACK:set(default, br)
            end
          else
            if i == 0 then
              break
            end
            i = i - 1
            a = this.EDGE_STACK:get(i)
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      return ar
    end
    InCircle = function (ax, ay, bx, by, cx, cy, px, py)
      local dx = ax - px
      local dy = ay - py
      local ex = bx - px
      local ey = by - py
      local fx = cx - px
      local fy = cy - py

      local ap = dx * dx + dy * dy
      local bp = ex * ex + ey * ey
      local cp = fx * fx + fy * fy

      return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0
    end
    AddTriangle = function (this, i0, i1, i2, a, b, c)
      local t = this.trianglesLen

      this.Triangles:set(t, i0)
      this.Triangles:set(t + 1, i1)
      this.Triangles:set(t + 2, i2)

      Link(this, t, a)
      Link(this, t + 1, b)
      Link(this, t + 2, c)

      this.trianglesLen = this.trianglesLen + 3
      return t
    end
    Link = function (this, a, b)
      this.Halfedges:set(a, b)
      if b ~= - 1 then
        this.Halfedges:set(b, a)
      end
    end
    HashKey = function (this, x, y)
      return System.ToInt32(System.modf(math.Floor(PseudoAngle(x - this.cx, y - this.cy) * this.hashSize), this.hashSize))
    end
    PseudoAngle = function (dx, dy)
      local p = dx / (math.Abs(dx) + math.Abs(dy))
      return ((dy > 0) and (3 - p) or (1 + p)) / 4
      -- [0..1]
    end
    Quicksort = function (ids, dists, left, right)
      if right - left <= 20 then
        for i = left + 1, right do
          local temp = ids:get(i)
          local tempDist = dists:get(temp)
          local j = i - 1
          while j >= left and dists:get(ids:get(j)) > tempDist do
            ids:set(j + 1, ids:get(j))
            j = j - 1
          end
          ids:set(j + 1, temp)
        end
      else
        local median = System.sr((left + right), 1)
        local i = left + 1
        local j = right
        Swap(ids, median, i)
        if dists:get(ids:get(left)) > dists:get(ids:get(right)) then
          Swap(ids, left, right)
        end
        if dists:get(ids:get(i)) > dists:get(ids:get(right)) then
          Swap(ids, i, right)
        end
        if dists:get(ids:get(left)) > dists:get(ids:get(i)) then
          Swap(ids, left, i)
        end

        local temp = ids:get(i)
        local tempDist = dists:get(temp)
        while true do
          repeat
            i = i + 1
          until not (dists:get(ids:get(i)) < tempDist)
          repeat
            j = j - 1
          until not (dists:get(ids:get(j)) > tempDist)
          if j < i then
            break
          end
          Swap(ids, i, j)
        end
        ids:set(left + 1, ids:get(j))
        ids:set(j, temp)

        if right - i + 1 >= j - left then
          Quicksort(ids, dists, i, right)
          Quicksort(ids, dists, left, j - 1)
        else
          Quicksort(ids, dists, left, j - 1)
          Quicksort(ids, dists, i, right)
        end
      end
    end
    Swap = function (arr, i, j)
      local tmp = arr:get(i)
      arr:set(i, arr:get(j))
      arr:set(j, tmp)
    end
    Orient = function (px, py, qx, qy, rx, ry)
      return (qy - py) * (rx - qx) - (qx - px) * (ry - qy) < 0
    end
    Circumradius = function (ax, ay, bx, by, cx, cy)
      local dx = bx - ax
      local dy = by - ay
      local ex = cx - ax
      local ey = cy - ay
      local bl = dx * dx + dy * dy
      local cl = ex * ex + ey * ey
      local d = 0.5 / (dx * ey - dy * ex)
      local x = (ey * bl - dy * cl) * d
      local y = (dx * cl - ex * bl) * d
      return x * x + y * y
    end
    Circumcenter = function (ax, ay, bx, by, cx, cy)
      local dx = bx - ax
      local dy = by - ay
      local ex = cx - ax
      local ey = cy - ay
      local bl = dx * dx + dy * dy
      local cl = ex * ex + ey * ey
      local d = 0.5 / (dx * ey - dy * ex)
      local x = ax + (ey * bl - dy * cl) * d
      local y = ay + (dx * cl - ex * bl) * d

      return DelaunatorSharp.Point(x, y)
    end
    Dist = function (ax, ay, bx, by)
      local dx = ax - bx
      local dy = ay - by
      return dx * dx + dy * dy
    end
    GetTriangles = function (this)
      return System.yieldIEnumerable(function (this)
        for t = 0, System.div(#this.Triangles, 3) - 1 do
          System.yield(DelaunatorSharp.Triangle(t, GetTrianglePoints(this, t)))
        end
      end, DelaunatorSharp.ITriangle, this)
    end
    GetEdges = function (this)
      return System.yieldIEnumerable(function (this)
        for e = 0, #this.Triangles - 1 do
          if e > this.Halfedges:get(e) then
            local p = this.Points:get(this.Triangles:get(e))
            local q = this.Points:get(this.Triangles:get(NextHalfedge(e)))
            System.yield(DelaunatorSharp.Edge(e, p, q))
          end
        end
      end, DelaunatorSharp.IEdge, this)
    end
    GetVoronoiEdges = function (this, triangleVerticeSelector)
      return System.yieldIEnumerable(function (this, triangleVerticeSelector)
        if triangleVerticeSelector == nil then
          triangleVerticeSelector = function (x)
            return GetCentroid(this, x)
          end
        end
        for e = 0, #this.Triangles - 1 do
          if e < this.Halfedges:get(e) then
            local p = triangleVerticeSelector(TriangleOfEdge(e))
            local q = triangleVerticeSelector(TriangleOfEdge(this.Halfedges:get(e)))
            System.yield(DelaunatorSharp.Edge(e, p, q))
          end
        end
      end, DelaunatorSharp.IEdge, this, triangleVerticeSelector)
    end
    GetVoronoiEdgesBasedOnCircumCenter = function (this)
      return GetVoronoiEdges(this, System.fn(this, GetTriangleCircumcenter))
    end
    GetVoronoiEdgesBasedOnCentroids = function (this)
      return GetVoronoiEdges(this, System.fn(this, GetCentroid))
    end
    GetVoronoiCells = function (this, triangleVerticeSelector)
      return System.yieldIEnumerable(function (this, triangleVerticeSelector)
        if triangleVerticeSelector == nil then
          triangleVerticeSelector = function (x)
            return GetCentroid(this, x)
          end
        end

        local seen = HashSetInt32()
        local vertices = ListIPoint(10)
        -- Keep it outside the loop, reuse capacity, less resizes.

        for e = 0, #this.Triangles - 1 do
          local pointIndex = this.Triangles:get(NextHalfedge(e))
          -- True if element was added, If resize the set? O(n) : O(1)
          if seen:Add(pointIndex) then
            for _, edge in System.each(EdgesAroundPoint(this, e)) do
              -- triangleVerticeSelector cant be null, no need to check before invoke (?.).
              vertices:Add(triangleVerticeSelector(TriangleOfEdge(edge)))
            end
            System.yield(DelaunatorSharp.VoronoiCell(pointIndex, vertices:ToArray()))
            vertices:Clear()
            -- Clear elements, keep capacity
          end
        end
      end, DelaunatorSharp.IVoronoiCell, this, triangleVerticeSelector)
    end
    GetVoronoiCellsBasedOnCircumcenters = function (this)
      return GetVoronoiCells(this, System.fn(this, GetTriangleCircumcenter))
    end
    GetVoronoiCellsBasedOnCentroids = function (this)
      return GetVoronoiCells(this, System.fn(this, GetCentroid))
    end
    GetHullEdges = function (this)
      return CreateHull(GetHullPoints(this))
    end
    GetHullPoints = function (this)
      return System.Array.ConvertAll(this.Hull, function (x)
        return this.Points:get(x)
      end, System.Int32, DelaunatorSharp.IPoint)
    end
    GetTrianglePoints = function (this, t)
      local points = ListIPoint()
      for _, p in System.each(PointsOfTriangle(this, t)) do
        points:Add(this.Points:get(p))
      end
      return points:ToArray()
    end
    GetRellaxedPoints = function (this)
      local points = ListIPoint()
      for _, cell in System.each(GetVoronoiCellsBasedOnCircumcenters(this)) do
        points:Add(GetCentroid1(cell:getPoints()))
      end
      return points:ToArray()
    end
    GetEdgesOfTriangle = function (this, t)
      local edges = EdgesOfTriangle(t)
      local points = ArrayIPoint(#edges)
      for i = 0, #edges - 1 do
        points:set(i, this.Points:get(edges:get(i)))
      end

      return CreateHull(points)
    end
    CreateHull = function (points)
      local edges = ArrayIEdge(points:getCount())
      for i = 1, points:getCount() - 1 do
        edges:set(i - 1, DelaunatorSharp.Edge(0, points:get(i - 1), points:get(i)))
      end

      if points:getCount() >= 2 then
        edges:set(points:getCount() - 1, DelaunatorSharp.Edge(0, points:get(points:getCount() - 1), points:get(0)))
      end

      return edges
    end
    GetTriangleCircumcenter = function (this, t)
      local vertices = GetTrianglePoints(this, t)
      return GetCircumcenter(vertices:get(0), vertices:get(1), vertices:get(2))
    end
    GetCentroid = function (this, t)
      local vertices = GetTrianglePoints(this, t)
      return GetCentroid1(vertices)
    end
    GetCircumcenter = function (a, b, c)
      return Circumcenter(a:getX(), a:getY(), b:getX(), b:getY(), c:getX(), c:getY())
    end
    GetCentroid1 = function (points)
      local accumulatedArea = 0.0
      local centerX = 0.0
      local centerY = 0.0

      do
        local i = 0 local j = #points - 1
        while i < #points do
          local temp = points:get(i):getX() * points:get(j):getY() - points:get(j):getX() * points:get(i):getY()
          accumulatedArea = accumulatedArea + temp
          centerX = centerX + (((points:get(i):getX() + points:get(j):getX()) * temp))
          centerY = centerY + (((points:get(i):getY() + points:get(j):getY()) * temp))
          local default = i
          i = default + 1
          j = default
        end
      end

      if math.Abs(accumulatedArea) < 1E-7 then
        return DelaunatorSharp.Point()
      end

      accumulatedArea = accumulatedArea * 3
      return DelaunatorSharp.Point(centerX / accumulatedArea, centerY / accumulatedArea)
    end
    ForEachTriangle = function (this, callback)
      for _, triangle in System.each(GetTriangles(this)) do
        local default = callback
        if default ~= nil then
          default(triangle)
        end
      end
    end
    ForEachTriangleEdge = function (this, callback)
      for _, edge in System.each(GetEdges(this)) do
        local default = callback
        if default ~= nil then
          default(edge)
        end
      end
    end
    ForEachVoronoiEdge = function (this, callback)
      for _, edge in System.each(GetVoronoiEdges(this)) do
        local default = callback
        if default ~= nil then
          default(edge)
        end
      end
    end
    ForEachVoronoiCellBasedOnCentroids = function (this, callback)
      for _, cell in System.each(GetVoronoiCellsBasedOnCentroids(this)) do
        local default = callback
        if default ~= nil then
          default(cell)
        end
      end
    end
    ForEachVoronoiCellBasedOnCircumcenters = function (this, callback)
      for _, cell in System.each(GetVoronoiCellsBasedOnCircumcenters(this)) do
        local default = callback
        if default ~= nil then
          default(cell)
        end
      end
    end
    ForEachVoronoiCell = function (this, callback, triangleVertexSelector)
      for _, cell in System.each(GetVoronoiCells(this, triangleVertexSelector)) do
        local default = callback
        if default ~= nil then
          default(cell)
        end
      end
    end
    -- <summary>
    -- Returns the half-edges that share a start point with the given half edge, in order.
    -- </summary>
    EdgesAroundPoint = function (this, start)
      return System.yieldIEnumerable(function (this, start)
        local incoming = start
        repeat
          System.yield(incoming)
          local outgoing = NextHalfedge(incoming)
          incoming = this.Halfedges:get(outgoing)
        until not (incoming ~= - 1 and incoming ~= start)
      end, System.Int32, this, start)
    end
    -- <summary>
    -- Returns the three point indices of a given triangle id.
    -- </summary>
    PointsOfTriangle = function (this, t)
      return System.yieldIEnumerable(function (this, t)
        for _, edge in System.each(EdgesOfTriangle(t)) do
          System.yield(this.Triangles:get(edge))
        end
      end, System.Int32, this, t)
    end
    -- <summary>
    -- Returns the triangle ids adjacent to the given triangle id.
    -- Will return up to three values.
    -- </summary>
    TrianglesAdjacentToTriangle = function (this, t)
      local adjacentTriangles = ListInt32()
      local triangleEdges = EdgesOfTriangle(t)
      for _, e in System.each(triangleEdges) do
        local opposite = this.Halfedges:get(e)
        if opposite >= 0 then
          adjacentTriangles:Add(TriangleOfEdge(opposite))
        end
      end
      return adjacentTriangles
    end
    NextHalfedge = function (e)
      return (System.mod(e, 3) == 2) and (e - 2) or (e + 1)
    end
    PreviousHalfedge = function (e)
      return (System.mod(e, 3) == 0) and (e + 2) or (e - 1)
    end
    -- <summary>
    -- Returns the three half-edges of a given triangle id.
    -- </summary>
    EdgesOfTriangle = function (t)
      return ArrayInt32 {
        3 * t,
        3 * t + 1,
        3 * t + 2
      }
    end
    -- <summary>
    -- Returns the triangle id of a given half-edge.
    -- </summary>
    TriangleOfEdge = function (e)
      return System.div(e, 3)
    end
    return {
      hashSize = 0,
      cx = 0,
      cy = 0,
      trianglesLen = 0,
      hullStart = 0,
      hullSize = 0,
      GetTriangles = GetTriangles,
      GetEdges = GetEdges,
      GetVoronoiEdges = GetVoronoiEdges,
      GetVoronoiEdgesBasedOnCircumCenter = GetVoronoiEdgesBasedOnCircumCenter,
      GetVoronoiEdgesBasedOnCentroids = GetVoronoiEdgesBasedOnCentroids,
      GetVoronoiCells = GetVoronoiCells,
      GetVoronoiCellsBasedOnCircumcenters = GetVoronoiCellsBasedOnCircumcenters,
      GetVoronoiCellsBasedOnCentroids = GetVoronoiCellsBasedOnCentroids,
      GetHullEdges = GetHullEdges,
      GetHullPoints = GetHullPoints,
      GetTrianglePoints = GetTrianglePoints,
      GetRellaxedPoints = GetRellaxedPoints,
      GetEdgesOfTriangle = GetEdgesOfTriangle,
      CreateHull = CreateHull,
      GetTriangleCircumcenter = GetTriangleCircumcenter,
      GetCentroid = GetCentroid,
      GetCircumcenter = GetCircumcenter,
      GetCentroid1 = GetCentroid1,
      ForEachTriangle = ForEachTriangle,
      ForEachTriangleEdge = ForEachTriangleEdge,
      ForEachVoronoiEdge = ForEachVoronoiEdge,
      ForEachVoronoiCellBasedOnCentroids = ForEachVoronoiCellBasedOnCentroids,
      ForEachVoronoiCellBasedOnCircumcenters = ForEachVoronoiCellBasedOnCircumcenters,
      ForEachVoronoiCell = ForEachVoronoiCell,
      EdgesAroundPoint = EdgesAroundPoint,
      PointsOfTriangle = PointsOfTriangle,
      TrianglesAdjacentToTriangle = TrianglesAdjacentToTriangle,
      NextHalfedge = NextHalfedge,
      PreviousHalfedge = PreviousHalfedge,
      EdgesOfTriangle = EdgesOfTriangle,
      TriangleOfEdge = TriangleOfEdge,
      __ctor__ = __ctor__
    }
  end)
end)
