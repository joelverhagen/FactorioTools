// DO NOT EDIT
// Generated by LinqGen.Generator
#nullable disable
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using Cathei.LinqGen;
using Cathei.LinqGen.Hidden;

namespace Cathei.LinqGen.Hidden
{
    // Non-exported Enumerable should consider anonymous type, thus it will be internal
    internal struct ThenBy_1B0is1 : IInternalOrderedStub<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal ThenBy_1B0is1(in ThenBy_zREfR1 source, global::System.Func<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk, double> selector_1B0is1) : this()
        {
            this.source_Prmo21 = source.source_Prmo21;
            this.selector_zANKn1 = source.selector_zANKn1;
            this.selector_zREfR1 = source.selector_zREfR1;
            this.selector_1B0is1 = selector_1B0is1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Count() => this.source_Prmo21.Count;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public List<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk> ToList()
        {
            var copy = this;
            PooledListManaged<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk> elements_1B0is1 = new PooledListManaged<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk>(0);
            PooledListNative<int> indices_1B0is1 = new PooledListNative<int>(0);
            int index_1B0is1 = default;
            int c1B0is1_index_Prmo21 = default;
            c1B0is1_index_Prmo21 = -1;
            var localElements_1B0is1 = new PooledListManaged<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk>(copy.source_Prmo21.Count);
            while (true)
            {
                if ((uint)++c1B0is1_index_Prmo21 >= (uint)copy.source_Prmo21.Count)
                    break;
                var current_Prmo21 = copy.source_Prmo21[c1B0is1_index_Prmo21];
                localElements_1B0is1.Add(current_Prmo21);
            }

            var min_1B0is1 = 0;
            var max_1B0is1 = localElements_1B0is1.Count - 1;
            if (max_1B0is1 >= min_1B0is1)
            {
                indices_1B0is1 = new PooledListNative<int>(localElements_1B0is1.Count);
                for (int i = 0; i < localElements_1B0is1.Count; ++i)
                    indices_1B0is1.Add(i);
                var sorter_1B0is1 = new ThenBy_1B0is1.Sorter(localElements_1B0is1, copy.selector_zANKn1, copy.selector_zREfR1, copy.selector_1B0is1);
                sorter_1B0is1.PartialQuickSort(indices_1B0is1.Array, 0, localElements_1B0is1.Count - 1, min_1B0is1, max_1B0is1);
                sorter_1B0is1.Dispose();
            }
            else
            {
                localElements_1B0is1.Dispose();
            }

            elements_1B0is1 = localElements_1B0is1;
            index_1B0is1 = min_1B0is1 - 1;
            var list_3M6lQ1 = new List<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk>(Count());
            try
            {
                while (true)
                {
                    if ((uint)++index_1B0is1 >= (uint)indices_1B0is1.Count)
                        break;
                    var current_1B0is1 = elements_1B0is1[indices_1B0is1[index_1B0is1]];
                    list_3M6lQ1.Add(current_1B0is1);
                }

                return list_3M6lQ1;
            }
            finally
            {
                elements_1B0is1.Dispose();
                indices_1B0is1.Dispose();
            }
        }

        internal struct Sorter : IComparer<int>, IDisposable
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public Sorter(PooledListManaged<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk> elements, global::System.Func<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk, int> selector_zANKn1, global::System.Func<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk, int> selector_zREfR1, global::System.Func<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk, double> selector_1B0is1)
            {
                this.comparer_zANKn1 = default;
                keys_zANKn1 = new PooledListNative<int>(elements.Count);
                for (int i = 0; i < elements.Count; ++i)
                    keys_zANKn1.Add(selector_zANKn1.Invoke(elements[i]));
                this.comparer_zREfR1 = default;
                keys_zREfR1 = new PooledListNative<int>(elements.Count);
                for (int i = 0; i < elements.Count; ++i)
                    keys_zREfR1.Add(selector_zREfR1.Invoke(elements[i]));
                this.comparer_1B0is1 = default;
                keys_1B0is1 = new PooledListNative<double>(elements.Count);
                for (int i = 0; i < elements.Count; ++i)
                    keys_1B0is1.Add(selector_1B0is1.Invoke(elements[i]));
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public int Compare(int x, int y)
            {
                int result;
                result = comparer_zANKn1.Compare(keys_zANKn1[x], keys_zANKn1[y]);
                if (result != 0)
                    return -result;
                result = comparer_zREfR1.Compare(keys_zREfR1[x], keys_zREfR1[y]);
                if (result != 0)
                    return result;
                result = comparer_1B0is1.Compare(keys_1B0is1[x], keys_1B0is1[y]);
                if (result != 0)
                    return result;
                return x - y;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose()
            {
                keys_zANKn1.Dispose();
                keys_zREfR1.Dispose();
                keys_1B0is1.Dispose();
            }

            public void PartialQuickSort(DynamicArrayNative<int> indexesToSort, int left, int right, int min, int max)
            {
                do
                {
                    int mid = PartitionHoare(indexesToSort, left, right);
                    if (left < mid && mid >= min)
                        PartialQuickSort(indexesToSort, left, mid, min, max);
                    left = mid + 1;
                }
                while (left < right && left <= max);
            }

            // Hoare partition scheme
            // This implementation is faster when using struct comparer (more comparison and less copy)
            private int PartitionHoare(DynamicArrayNative<int> indexesToSort, int left, int right)
            {
                // preventing overflow of the pivot
                int pivot = left + ((right - left) >> 1);
                int pivotIndex = indexesToSort[pivot];
                int i = left - 1;
                int j = right + 1;
                while (true)
                {
                    // Move the left index to the right at least once and while the element at
                    // the left index is less than the pivot
                    while (Compare(indexesToSort[++i], pivotIndex) < 0)
                        ;
                    // Move the right index to the left at least once and while the element at
                    // the right index is greater than the pivot
                    while (Compare(indexesToSort[--j], pivotIndex) > 0)
                        ;
                    // If the indices crossed, return
                    if (i >= j)
                        return j;
                    // Swap the elements at the left and right indices
                    (indexesToSort[i], indexesToSort[j]) = (indexesToSort[j], indexesToSort[i]);
                }
            }

            private ValueCompareToComparer<int> comparer_zANKn1;
            private PooledListNative<int> keys_zANKn1;
            private ValueCompareToComparer<int> comparer_zREfR1;
            private PooledListNative<int> keys_zREfR1;
            private ValueCompareToComparer<double> comparer_1B0is1;
            private PooledListNative<double> keys_1B0is1;
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        internal global::System.Collections.Generic.List<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk> source_Prmo21;
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal global::System.Func<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk, int> selector_zANKn1;
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal global::System.Func<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk, int> selector_zREfR1;
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal global::System.Func<global::Knapcode.FactorioTools.OilField.AddPipes.Trunk, double> selector_1B0is1;
    }
}

namespace Cathei.LinqGen
{
}